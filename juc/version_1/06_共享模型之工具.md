# å…±äº«æ¨¡å‹ä¹‹å·¥å…·

## 1. çº¿ç¨‹æ± 

### 1. è‡ªå®šä¹‰çº¿ç¨‹æ± 

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192108696.png)

**1. è‡ªå®šä¹‰æ‹’ç»ç­–ç•¥æ¥å£**

```java
@FunctionalInterface // æ‹’ç»ç­–ç•¥
interface RejectPolicy<T> {
    void reject(BlockingQueue<T> queue, T task);
}
```



**2. è‡ªå®šä¹‰ä»»åŠ¡é˜Ÿåˆ—**

```java
class BlockingQueue<T> {
    // 1. ä»»åŠ¡é˜Ÿåˆ—
    private Deque<T> queue = new ArrayDeque<>();

    // 2. é”
    private ReentrantLock lock = new ReentrantLock();

    // 3. ç”Ÿäº§è€…æ¡ä»¶å˜é‡
    private Condition fullWaitSet = lock.newCondition();

    // 4. æ¶ˆè´¹è€…æ¡ä»¶å˜é‡
    private Condition emptyWaitSet = lock.newCondition();

    // 5. å®¹é‡
    private int capcity;

    public BlockingQueue(int capcity) {
        this.capcity = capcity;
    }

    // å¸¦è¶…æ—¶é˜»å¡è·å–
    public T poll(long timeout, TimeUnit unit) {
        lock.lock();
        try {
            // å°† timeout ç»Ÿä¸€è½¬æ¢ä¸º çº³ç§’
            long nanos = unit.toNanos(timeout);
            while (queue.isEmpty()) {
                try {
                    // è¿”å›å€¼æ˜¯å‰©ä½™æ—¶é—´
                    if (nanos <= 0) {
                        return null;
                    }
                    nanos = emptyWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = queue.removeFirst();
            fullWaitSet.signal();
            return t;
        } finally {
            lock.unlock();
        }
    }

    // é˜»å¡è·å–
    public T take() {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                try {
                    emptyWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = queue.removeFirst();
            fullWaitSet.signal();
            return t;
        } finally {
            lock.unlock();
        }
    }

    // é˜»å¡æ·»åŠ 
    public void put(T task) {
        lock.lock();
        try {
            while (queue.size() == capcity) {
                try {
                    log.debug("ç­‰å¾…åŠ å…¥ä»»åŠ¡é˜Ÿåˆ— {} ...", task);
                    fullWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("åŠ å…¥ä»»åŠ¡é˜Ÿåˆ— {}", task);
            queue.addLast(task);
            emptyWaitSet.signal();
        } finally {
            lock.unlock();
        }
    }

    // å¸¦è¶…æ—¶æ—¶é—´é˜»å¡æ·»åŠ 
    public boolean offer(T task, long timeout, TimeUnit timeUnit) {
        lock.lock();
        try {
            long nanos = timeUnit.toNanos(timeout);
            while (queue.size() == capcity) {
                try {
                    if(nanos <= 0) {
                        return false;
                    }
                    log.debug("ç­‰å¾…åŠ å…¥ä»»åŠ¡é˜Ÿåˆ— {} ...", task);
                    nanos = fullWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("åŠ å…¥ä»»åŠ¡é˜Ÿåˆ— {}", task);
            queue.addLast(task);
            emptyWaitSet.signal();
            return true;
        } finally {
            lock.unlock();
        }
    }

    public int size() {
        lock.lock();
        try {
            return queue.size();
        } finally {
            lock.unlock();
        }
    }

    public void tryPut(RejectPolicy<T> rejectPolicy, T task) {
        lock.lock();
        try {
            // åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦æ»¡
            if(queue.size() == capcity) {
                rejectPolicy.reject(this, task);
            } else {  // æœ‰ç©ºé—²
                log.debug("åŠ å…¥ä»»åŠ¡é˜Ÿåˆ— {}", task);
                queue.addLast(task);
                emptyWaitSet.signal();
            }
        } finally {
            lock.unlock();
        }
    }
}
```



**3. è‡ªå®šä¹‰çº¿ç¨‹æ± **

```java
class ThreadPool {
    // ä»»åŠ¡é˜Ÿåˆ—
    private BlockingQueue<Runnable> taskQueue;

    // çº¿ç¨‹é›†åˆ
    private HashSet<Worker> workers = new HashSet<>();

    // æ ¸å¿ƒçº¿ç¨‹æ•°
    private int coreSize;

    // è·å–ä»»åŠ¡æ—¶çš„è¶…æ—¶æ—¶é—´
    private long timeout;

    private TimeUnit timeUnit;

    private RejectPolicy<Runnable> rejectPolicy;

    // æ‰§è¡Œä»»åŠ¡
    public void execute(Runnable task) {
        // å½“ä»»åŠ¡æ•°æ²¡æœ‰è¶…è¿‡ coreSize æ—¶ï¼Œç›´æ¥äº¤ç»™ worker å¯¹è±¡æ‰§è¡Œ
        // å¦‚æœä»»åŠ¡æ•°è¶…è¿‡ coreSize æ—¶ï¼ŒåŠ å…¥ä»»åŠ¡é˜Ÿåˆ—æš‚å­˜
        synchronized (workers) {
            if(workers.size() < coreSize) {
                Worker worker = new Worker(task);
                log.debug("æ–°å¢ worker{}, {}", worker, task);
                workers.add(worker);
                worker.start();
            } else {
//                taskQueue.put(task);
                // 1) æ­»ç­‰
                // 2) å¸¦è¶…æ—¶ç­‰å¾…
                // 3) è®©è°ƒç”¨è€…æ”¾å¼ƒä»»åŠ¡æ‰§è¡Œ
                // 4) è®©è°ƒç”¨è€…æŠ›å‡ºå¼‚å¸¸
                // 5) è®©è°ƒç”¨è€…è‡ªå·±æ‰§è¡Œä»»åŠ¡
                taskQueue.tryPut(rejectPolicy, task);
            }
        }
    }

    public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit, int queueCapcity, RejectPolicy<Runnable> rejectPolicy) {
        this.coreSize = coreSize;
        this.timeout = timeout;
        this.timeUnit = timeUnit;
        this.taskQueue = new BlockingQueue<>(queueCapcity);
        this.rejectPolicy = rejectPolicy;
    }

    class Worker extends Thread{
        private Runnable task;

        public Worker(Runnable task) {
            this.task = task;
        }

        @Override
        public void run() {
            // æ‰§è¡Œä»»åŠ¡
            // 1) å½“ task ä¸ä¸ºç©ºï¼Œæ‰§è¡Œä»»åŠ¡
            // 2) å½“ task æ‰§è¡Œå®Œæ¯•ï¼Œå†æ¥ç€ä»ä»»åŠ¡é˜Ÿåˆ—è·å–ä»»åŠ¡å¹¶æ‰§è¡Œ
//            while(task != null || (task = taskQueue.take()) != null) {
            while(task != null || (task = taskQueue.poll(timeout, timeUnit)) != null) {
                try {
                    log.debug("æ­£åœ¨æ‰§è¡Œ...{}", task);
                    task.run();
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    task = null;
                }
            }
            synchronized (workers) {
                log.debug("worker è¢«ç§»é™¤{}", this);
                workers.remove(this);
            }
        }
    }
}
```



**4. æµ‹è¯•**

```java
public class TestPool {
    public static void main(String[] args) {
        ThreadPool threadPool = new ThreadPool(1,
                1000, TimeUnit.MILLISECONDS, 1, (queue, task)->{
            // 1. æ­»ç­‰
//            queue.put(task);
            // 2. å¸¦è¶…æ—¶ç­‰å¾…
//            queue.offer(task, 1500, TimeUnit.MILLISECONDS);
            // 3. è®©è°ƒç”¨è€…æ”¾å¼ƒä»»åŠ¡æ‰§è¡Œ
//            log.debug("æ”¾å¼ƒ{}", task);
            // 4. è®©è°ƒç”¨è€…æŠ›å‡ºå¼‚å¸¸
//            throw new RuntimeException("ä»»åŠ¡æ‰§è¡Œå¤±è´¥ " + task);
            // 5. è®©è°ƒç”¨è€…è‡ªå·±æ‰§è¡Œä»»åŠ¡
            task.run();
        });
        for (int i = 0; i < 4; i++) {
            int j = i;
            threadPool.execute(() -> {
                try {
                    Thread.sleep(1000L);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("{}", j);
            });
        }
    }
}
```





### 2. ThreadPoolExecutor

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192110814.png)



#### 1. çº¿ç¨‹æ± çŠ¶æ€

ThreadPoolExecutor ä½¿ç”¨ int çš„é«˜ 3 ä½æ¥è¡¨ç¤ºçº¿ç¨‹æ± çŠ¶æ€ï¼Œä½ 29 ä½è¡¨ç¤ºçº¿ç¨‹æ•°é‡

| çŠ¶æ€å     | é«˜ 3 ä½ | æ¥æ”¶æ–°ä»»åŠ¡ | å¤„ç†é˜»å¡é˜Ÿåˆ—ä»»åŠ¡ | è¯´æ˜                                      |
| ---------- | ------- | ---------- | ---------------- | ----------------------------------------- |
| RUNNING    | 111     | Y          | Y                |                                           |
| SHUTDOWN   | 000     | N          | Y                | ä¸ä¼šæ¥æ”¶æ–°ä»»åŠ¡ï¼Œä½†ä¼šå¤„ç†é˜»å¡é˜Ÿåˆ—å‰©ä½™ä»»åŠ¡  |
| STOP       | 001     | N          | N                | ä¼šä¸­æ–­æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡ï¼Œå¹¶æŠ›å¼ƒé˜»å¡é˜Ÿåˆ—ä»»åŠ¡  |
| TIDYING    | 010     | -          | -                | ä»»åŠ¡å…¨æ‰§è¡Œå®Œæ¯•ï¼Œæ´»åŠ¨çº¿ç¨‹ä¸º 0 å³å°†è¿›å…¥ç»ˆç»“ |
| TERMINATED | 011     | -          | -                | ç»ˆç»“çŠ¶æ€                                  |

ä»æ•°å­—ä¸Šæ¯”è¾ƒï¼ŒTERMINATED > TIDYING > STOP > SHUTDOWN > RUNNING

è¿™äº›ä¿¡æ¯å­˜å‚¨åœ¨ä¸€ä¸ªåŸå­å˜é‡ ctl ä¸­ï¼Œç›®çš„æ˜¯å°†çº¿ç¨‹æ± çŠ¶æ€ä¸çº¿ç¨‹ä¸ªæ•°åˆäºŒä¸ºä¸€ï¼Œè¿™æ ·å°±å¯ä»¥ç”¨ä¸€æ¬¡ cas åŸå­æ“ä½œ è¿›è¡Œèµ‹å€¼

```java
// c ä¸ºæ—§å€¼ï¼Œ ctlOf è¿”å›ç»“æœä¸ºæ–°å€¼
ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));

// rs ä¸ºé«˜ 3 ä½ä»£è¡¨çº¿ç¨‹æ± çŠ¶æ€ï¼Œ wc ä¸ºä½ 29 ä½ä»£è¡¨çº¿ç¨‹ä¸ªæ•°ï¼Œctl æ˜¯åˆå¹¶å®ƒä»¬
private static int ctlOf(int rs, int wc) { return rs | wc; }
```





#### 2. æ„é€ æ–¹æ³•

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)

```

- corePoolSize æ ¸å¿ƒçº¿ç¨‹æ•°ç›® (æœ€å¤šä¿ç•™çš„çº¿ç¨‹æ•°)
- maximumPoolSize æœ€å¤§çº¿ç¨‹æ•°ç›®
- keepAliveTime ç”Ÿå­˜æ—¶é—´ - é’ˆå¯¹æ•‘æ€¥çº¿ç¨‹
- unit æ—¶é—´å•ä½ - é’ˆå¯¹æ•‘æ€¥çº¿ç¨‹
- workQueue é˜»å¡é˜Ÿåˆ—
- threadFactory çº¿ç¨‹å·¥å‚ - å¯ä»¥ä¸ºçº¿ç¨‹åˆ›å»ºæ—¶èµ·ä¸ªå¥½åå­—
- handler æ‹’ç»ç­–ç•¥

**å·¥ä½œæ–¹å¼ï¼š**

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192110820.png)

- çº¿ç¨‹æ± ä¸­åˆšå¼€å§‹æ²¡æœ‰çº¿ç¨‹ï¼Œå½“ä¸€ä¸ªä»»åŠ¡æäº¤ç»™çº¿ç¨‹æ± åï¼Œçº¿ç¨‹æ± ä¼šåˆ›å»ºä¸€ä¸ªæ–°çº¿ç¨‹æ¥æ‰§è¡Œä»»åŠ¡ã€‚
- å½“çº¿ç¨‹æ•°è¾¾åˆ° corePoolSize å¹¶æ²¡æœ‰çº¿ç¨‹ç©ºé—²ï¼Œè¿™æ—¶å†åŠ å…¥ä»»åŠ¡ï¼Œæ–°åŠ çš„ä»»åŠ¡ä¼šè¢«åŠ å…¥workQueue é˜Ÿåˆ—æ’ é˜Ÿï¼Œç›´åˆ°æœ‰ç©ºé—²çš„çº¿ç¨‹ã€‚
- å¦‚æœé˜Ÿåˆ—é€‰æ‹©äº†æœ‰ç•Œé˜Ÿåˆ—ï¼Œé‚£ä¹ˆä»»åŠ¡è¶…è¿‡äº†é˜Ÿåˆ—å¤§å°æ—¶ï¼Œä¼šåˆ›å»º maximumPoolSize - corePoolSize æ•°ç›®çš„çº¿ ç¨‹æ¥æ•‘æ€¥ã€‚
- å¦‚æœçº¿ç¨‹åˆ°è¾¾ maximumPoolSize ä»ç„¶æœ‰æ–°ä»»åŠ¡è¿™æ—¶ä¼šæ‰§è¡Œæ‹’ç»ç­–ç•¥ã€‚æ‹’ç»ç­–ç•¥ jdk æä¾›äº† 4 ç§å®ç°ï¼Œå…¶å®ƒ è‘—åæ¡†æ¶ä¹Ÿæä¾›äº†å®ç°
  - AbortPolicy è®©è°ƒç”¨è€…æŠ›å‡º RejectedExecutionException å¼‚å¸¸ï¼Œè¿™æ˜¯é»˜è®¤ç­–ç•¥
  - CallerRunsPolicy è®©è°ƒç”¨è€…è¿è¡Œä»»åŠ¡
  - DiscardPolicy æ”¾å¼ƒæœ¬æ¬¡ä»»åŠ¡
  - DiscardOldestPolicy æ”¾å¼ƒé˜Ÿåˆ—ä¸­æœ€æ—©çš„ä»»åŠ¡ï¼Œæœ¬ä»»åŠ¡å–è€Œä»£ä¹‹
  - Dubbo çš„å®ç°ï¼Œåœ¨æŠ›å‡º RejectedExecutionException å¼‚å¸¸ä¹‹å‰ä¼šè®°å½•æ—¥å¿—ï¼Œå¹¶ dump çº¿ç¨‹æ ˆä¿¡æ¯ï¼Œæ–¹ ä¾¿å®šä½é—®é¢˜
  - Netty çš„å®ç°ï¼Œæ˜¯åˆ›å»ºä¸€ä¸ªæ–°çº¿ç¨‹æ¥æ‰§è¡Œä»»åŠ¡
  - ActiveMQ çš„å®ç°ï¼Œå¸¦è¶…æ—¶ç­‰å¾…ï¼ˆ60sï¼‰å°è¯•æ”¾å…¥é˜Ÿåˆ—ï¼Œç±»ä¼¼æˆ‘ä»¬ä¹‹å‰è‡ªå®šä¹‰çš„æ‹’ç»ç­–ç•¥
  - PinPoint çš„å®ç°ï¼Œå®ƒä½¿ç”¨äº†ä¸€ä¸ªæ‹’ç»ç­–ç•¥é“¾ï¼Œä¼šé€ä¸€å°è¯•ç­–ç•¥é“¾ä¸­æ¯ç§æ‹’ç»ç­–ç•¥
- å½“é«˜å³°è¿‡å»åï¼Œè¶…è¿‡corePoolSize çš„æ•‘æ€¥çº¿ç¨‹å¦‚æœä¸€æ®µæ—¶é—´æ²¡æœ‰ä»»åŠ¡åšï¼Œéœ€è¦ç»“æŸèŠ‚çœèµ„æºï¼Œè¿™ä¸ªæ—¶é—´ç”± keepAliveTime å’Œ unit æ¥æ§åˆ¶ã€‚

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192111092.png)

æ ¹æ®è¿™ä¸ªæ„é€ æ–¹æ³•ï¼ŒJDK Executors ç±»ä¸­æä¾›äº†ä¼—å¤šå·¥å‚æ–¹æ³•æ¥åˆ›å»ºå„ç§ç”¨é€”çš„çº¿ç¨‹æ± 





#### 3. newFixedThreadPool

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

**ç‰¹ç‚¹**

- æ ¸å¿ƒçº¿ç¨‹æ•° == æœ€å¤§çº¿ç¨‹æ•°ï¼ˆæ²¡æœ‰æ•‘æ€¥çº¿ç¨‹è¢«åˆ›å»ºï¼‰ï¼Œå› æ­¤ä¹Ÿæ— éœ€è¶…æ—¶æ—¶é—´
- é˜»å¡é˜Ÿåˆ—æ˜¯æ— ç•Œçš„ï¼Œå¯ä»¥æ”¾ä»»æ„æ•°é‡çš„ä»»åŠ¡

> **è¯„ä»·** 
>
> é€‚ç”¨äºä»»åŠ¡é‡å·²çŸ¥ï¼Œç›¸å¯¹è€—æ—¶çš„ä»»åŠ¡





#### 4. newCachedThreadPool

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

**ç‰¹ç‚¹**

- æ ¸å¿ƒçº¿ç¨‹æ•°æ˜¯ 0ï¼Œ æœ€å¤§çº¿ç¨‹æ•°æ˜¯ Integer.MAX_VALUEï¼Œæ•‘æ€¥çº¿ç¨‹çš„ç©ºé—²ç”Ÿå­˜æ—¶é—´æ˜¯ 60sï¼Œæ„å‘³ç€
  - å…¨éƒ¨éƒ½æ˜¯æ•‘æ€¥çº¿ç¨‹ï¼ˆ60s åå¯ä»¥å›æ”¶ï¼‰
  - æ•‘æ€¥çº¿ç¨‹å¯ä»¥æ— é™åˆ›å»º
- é˜Ÿåˆ—é‡‡ç”¨äº† SynchronousQueue å®ç°ç‰¹ç‚¹æ˜¯ï¼Œå®ƒæ²¡æœ‰å®¹é‡ï¼Œæ²¡æœ‰çº¿ç¨‹æ¥å–æ˜¯æ”¾ä¸è¿›å»çš„ï¼ˆä¸€æ‰‹äº¤é’±ã€ä¸€æ‰‹äº¤ è´§ï¼‰

 ```java
 public class TestSynchronousQueue {
     public static void main(String[] args) {
         SynchronousQueue<Integer> integers = new SynchronousQueue<>();
         new Thread(() -> {
             try {
                 log.debug("putting {} ", 1);
                 integers.put(1);
                 log.debug("{} putted...", 1);
 
                 log.debug("putting...{} ", 2);
                 integers.put(2);
                 log.debug("{} putted...", 2);
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
         },"t1").start();
 
         sleep(1);
 
         new Thread(() -> {
             try {
                 log.debug("taking {}", 1);
                 integers.take();
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
         },"t2").start();
 
         sleep(1);
 
         new Thread(() -> {
             try {
                 log.debug("taking {}", 2);
                 integers.take();
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
         },"t3").start();
     }
 }
 ```

```shell
# è¾“å‡º
11:34:29.270 c.TestSynchronousQueue [t1] - putting 1 
11:34:30.303 c.TestSynchronousQueue [t2] - taking 1
11:34:30.304 c.TestSynchronousQueue [t1] - 1 putted...
11:34:30.304 c.TestSynchronousQueue [t1] - putting...2 
11:34:31.308 c.TestSynchronousQueue [t3] - taking 2
11:34:31.309 c.TestSynchronousQueue [t1] - 2 putted...
```

> **è¯„ä»·** 
>
> æ•´ä¸ªçº¿ç¨‹æ± è¡¨ç°ä¸ºçº¿ç¨‹æ•°ä¼šæ ¹æ®ä»»åŠ¡é‡ä¸æ–­å¢é•¿ï¼Œæ²¡æœ‰ä¸Šé™ï¼Œå½“ä»»åŠ¡æ‰§è¡Œå®Œæ¯•ï¼Œç©ºé—² 1åˆ†é’Ÿåé‡Šæ”¾çº¿ ç¨‹ã€‚ é€‚åˆä»»åŠ¡æ•°æ¯”è¾ƒå¯†é›†ï¼Œä½†æ¯ä¸ªä»»åŠ¡æ‰§è¡Œæ—¶é—´è¾ƒçŸ­çš„æƒ…å†µ





#### 5. newSingleThreadExecutor

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

**ä½¿ç”¨åœºæ™¯ï¼š**

å¸Œæœ›å¤šä¸ªä»»åŠ¡æ’é˜Ÿæ‰§è¡Œã€‚çº¿ç¨‹æ•°å›ºå®šä¸º 1ï¼Œä»»åŠ¡æ•°å¤šäº 1 æ—¶ï¼Œä¼šæ”¾å…¥æ— ç•Œé˜Ÿåˆ—æ’é˜Ÿã€‚ä»»åŠ¡æ‰§è¡Œå®Œæ¯•ï¼Œè¿™å”¯ä¸€çš„çº¿ç¨‹ ä¹Ÿä¸ä¼šè¢«é‡Šæ”¾ã€‚

**åŒºåˆ«ï¼š**

- è‡ªå·±åˆ›å»ºä¸€ä¸ªå•çº¿ç¨‹ä¸²è¡Œæ‰§è¡Œä»»åŠ¡ï¼Œå¦‚æœä»»åŠ¡æ‰§è¡Œå¤±è´¥è€Œç»ˆæ­¢é‚£ä¹ˆæ²¡æœ‰ä»»ä½•è¡¥æ•‘æªæ–½ï¼Œè€Œçº¿ç¨‹æ± è¿˜ä¼šæ–°å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œä¿è¯æ± çš„æ­£å¸¸å·¥ä½œ

- `Executors.newSingleThreadExecutor()` çº¿ç¨‹ä¸ªæ•°å§‹ç»ˆä¸º1ï¼Œä¸èƒ½ä¿®æ”¹
  - `FinalizableDelegatedExecutorService` åº”ç”¨çš„æ˜¯è£…é¥°å™¨æ¨¡å¼ï¼Œåªå¯¹å¤–æš´éœ²äº† `ExecutorService` æ¥å£ï¼Œå› æ­¤ä¸èƒ½è°ƒç”¨ ` ThreadPoolExecutor` ä¸­ç‰¹æœ‰çš„æ–¹æ³•
- `Executors.newFixedThreadPool(1)` åˆå§‹æ—¶ä¸º1ï¼Œä»¥åè¿˜å¯ä»¥ä¿®æ”¹
  - å¯¹å¤–æš´éœ²çš„æ˜¯ `ThreadPoolExecutor` å¯¹è±¡ï¼Œå¯ä»¥å¼ºè½¬åè°ƒç”¨ `setCorePoolSize` ç­‰æ–¹æ³•è¿›è¡Œä¿®æ”¹





#### 6. æäº¤ä»»åŠ¡

```java
// æ‰§è¡Œä»»åŠ¡
void execute(Runnable command);

// æäº¤ä»»åŠ¡ taskï¼Œç”¨è¿”å›å€¼ Future è·å¾—ä»»åŠ¡æ‰§è¡Œç»“æœ
<T> Future<T> submit(Callable<T> task);

// æäº¤ tasks ä¸­æ‰€æœ‰ä»»åŠ¡
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
    throws InterruptedException;

// æäº¤ tasks ä¸­æ‰€æœ‰ä»»åŠ¡ï¼Œå¸¦è¶…æ—¶æ—¶é—´
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
                              long timeout, TimeUnit unit)
    throws InterruptedException;

// æäº¤ tasks ä¸­æ‰€æœ‰ä»»åŠ¡ï¼Œå“ªä¸ªä»»åŠ¡å…ˆæˆåŠŸæ‰§è¡Œå®Œæ¯•ï¼Œè¿”å›æ­¤ä»»åŠ¡æ‰§è¡Œç»“æœï¼Œå…¶å®ƒä»»åŠ¡å–æ¶ˆ
<T> T invokeAny(Collection<? extends Callable<T>> tasks)
    throws InterruptedException, ExecutionException;

// æäº¤ tasks ä¸­æ‰€æœ‰ä»»åŠ¡ï¼Œå“ªä¸ªä»»åŠ¡å…ˆæˆåŠŸæ‰§è¡Œå®Œæ¯•ï¼Œè¿”å›æ­¤ä»»åŠ¡æ‰§è¡Œç»“æœï¼Œå…¶å®ƒä»»åŠ¡å–æ¶ˆï¼Œå¸¦è¶…æ—¶æ—¶é—´
<T> T invokeAny(Collection<? extends Callable<T>> tasks,
                long timeout, TimeUnit unit)
    throws InterruptedException, ExecutionException, TimeoutException;
```





#### 7. å…³é—­çº¿ç¨‹æ± 

**1. shutdown**

```java
/*
 çº¿ç¨‹æ± çŠ¶æ€å˜ä¸º SHUTDOWN
	- ä¸ä¼šæ¥æ”¶æ–°ä»»åŠ¡
	- ä½†å·²æäº¤ä»»åŠ¡ä¼šæ‰§è¡Œå®Œ
	- æ­¤æ–¹æ³•ä¸ä¼šé˜»å¡è°ƒç”¨çº¿ç¨‹çš„æ‰§è¡Œ
*/
void shutdown();
```

```java
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        // ä¿®æ”¹çº¿ç¨‹æ± çŠ¶æ€
        advanceRunState(SHUTDOWN);
        // ä»…ä¼šæ‰“æ–­ç©ºé—²çº¿ç¨‹
        interruptIdleWorkers();
        onShutdown(); // æ‰©å±•ç‚¹ ScheduledThreadPoolExecutor
    } finally {
        mainLock.unlock();
    }
    // å°è¯•ç»ˆç»“(æ²¡æœ‰è¿è¡Œçš„çº¿ç¨‹å¯ä»¥ç«‹åˆ»ç»ˆç»“ï¼Œå¦‚æœè¿˜æœ‰è¿è¡Œçš„çº¿ç¨‹ä¹Ÿä¸ä¼šç­‰)
    tryTerminate();
}
```



**2. shutdownNow**

```java
/*
 çº¿ç¨‹æ± çŠ¶æ€å˜ä¸º STOP
	- ä¸ä¼šæ¥æ”¶æ–°ä»»åŠ¡
	- ä¼šå°†é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡è¿”å›
	- å¹¶ç”¨ interrupt çš„æ–¹å¼ä¸­æ–­æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡
*/
List<Runnable> shutdownNow();
```

```java
public List<Runnable> shutdownNow() {
    List<Runnable> tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        // ä¿®æ”¹çº¿ç¨‹æ± çŠ¶æ€
        advanceRunState(STOP);
        // æ‰“æ–­æ‰€æœ‰çº¿ç¨‹
        interruptWorkers();
        // è·å–é˜Ÿåˆ—ä¸­å‰©ä½™ä»»åŠ¡
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    // å°è¯•ç»ˆç»“
    tryTerminate();
    return tasks;
}
```



**3. å…¶å®ƒæ–¹æ³•**

```java
// ä¸åœ¨ RUNNING çŠ¶æ€çš„çº¿ç¨‹æ± ï¼Œæ­¤æ–¹æ³•å°±è¿”å› true
boolean isShutdown();

// çº¿ç¨‹æ± çŠ¶æ€æ˜¯å¦æ˜¯ TERMINATED
boolean isTerminated();

// è°ƒç”¨ shutdown åï¼Œç”±äºè°ƒç”¨çº¿ç¨‹å¹¶ä¸ä¼šç­‰å¾…æ‰€æœ‰ä»»åŠ¡è¿è¡Œç»“æŸï¼Œå› æ­¤å¦‚æœå®ƒæƒ³åœ¨çº¿ç¨‹æ±  TERMINATED ååšäº›äº‹æƒ…ï¼Œå¯ä»¥åˆ©ç”¨æ­¤æ–¹æ³•ç­‰å¾…
boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;
```





#### 8. ä»»åŠ¡è°ƒåº¦çº¿ç¨‹æ± 

åœ¨ã€ä»»åŠ¡è°ƒåº¦çº¿ç¨‹æ± ã€åŠŸèƒ½åŠ å…¥ä¹‹å‰ï¼Œå¯ä»¥ä½¿ç”¨ java.util.Timer æ¥å®ç°å®šæ—¶åŠŸèƒ½ï¼ŒTimer çš„ä¼˜ç‚¹åœ¨äºç®€å•æ˜“ç”¨ï¼Œä½†ç”±äºæ‰€æœ‰ä»»åŠ¡éƒ½æ˜¯ç”±åŒä¸€ä¸ªçº¿ç¨‹æ¥è°ƒåº¦ï¼Œå› æ­¤æ‰€æœ‰ä»»åŠ¡éƒ½æ˜¯ä¸²è¡Œæ‰§è¡Œçš„ï¼ŒåŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªä»»åŠ¡åœ¨æ‰§è¡Œï¼Œå‰ä¸€ä¸ªä»»åŠ¡çš„å»¶è¿Ÿæˆ–å¼‚å¸¸éƒ½å°†ä¼šå½±å“åˆ°ä¹‹åçš„ä»»åŠ¡ã€‚

**1. Timer**

```java
public static void main(String[] args) {
    Timer timer = new Timer();
    TimerTask task1 = new TimerTask() {
        @Override
        public void run() {
            log.debug("task 1");
            sleep(2);
        }
    };
    
    TimerTask task2 = new TimerTask() {
        @Override
        public void run() {
            log.debug("task 2");
        }
    };
    
    // ä½¿ç”¨ timer æ·»åŠ ä¸¤ä¸ªä»»åŠ¡ï¼Œå¸Œæœ›å®ƒä»¬éƒ½åœ¨ 1s åæ‰§è¡Œ
    // ä½†ç”±äº timer å†…åªæœ‰ä¸€ä¸ªçº¿ç¨‹æ¥é¡ºåºæ‰§è¡Œé˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ï¼Œå› æ­¤ã€ä»»åŠ¡1ã€çš„å»¶æ—¶ï¼Œå½±å“äº†ã€ä»»åŠ¡2ã€çš„æ‰§è¡Œ
    timer.schedule(task1, 1000);
    timer.schedule(task2, 1000);
}
```



**2. ScheduledExecutorService**

```java
private static void method2(ScheduledExecutorService pool) {
    pool.schedule(() -> {
        log.debug("task1");
        int i = 1 / 0;
    }, 1, TimeUnit.SECONDS);

    pool.schedule(() -> {
        log.debug("task2");
    }, 1, TimeUnit.SECONDS);
}
```



**3. scheduleAtFixedRate**

```java
private static void method3() {
    ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);
    log.debug("start...");
    pool.scheduleAtFixedRate(() -> {
        log.debug("running...");
    }, 1, 1, TimeUnit.SECONDS);
}
```



**4. scheduleWithFixedDelay**

```java
private static void method4() {
    ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);
    log.debug("start...");
    pool.scheduleWithFixedDelay(()-> {
        log.debug("running...");
        sleep(2);
    }, 1, 1, TimeUnit.SECONDS);
}
```

> **è¯„ä»·** 
>
> æ•´ä¸ªçº¿ç¨‹æ± è¡¨ç°ä¸ºï¼šçº¿ç¨‹æ•°å›ºå®šï¼Œä»»åŠ¡æ•°å¤šäºçº¿ç¨‹æ•°æ—¶ï¼Œä¼šæ”¾å…¥æ— ç•Œé˜Ÿåˆ—æ’é˜Ÿã€‚ä»»åŠ¡æ‰§è¡Œå®Œæ¯•ï¼Œè¿™äº›çº¿ç¨‹ä¹Ÿä¸ä¼šè¢«é‡Šæ”¾ã€‚ç”¨æ¥æ‰§è¡Œå»¶è¿Ÿæˆ–åå¤æ‰§è¡Œçš„ä»»åŠ¡





#### 9. æ­£ç¡®å¤„ç†æ‰§è¡Œä»»åŠ¡å¼‚å¸¸

**æ–¹æ³•1ï¼šä¸»åŠ¨æ‰å¼‚å¸¸**

```java
ExecutorService pool = Executors.newFixedThreadPool(1);
pool.submit(() -> {
    try {
        log.debug("task1");
        int i = 1 / 0;
    } catch (Exception e) {
        log.error("error:", e);
    }
});
```



**æ–¹æ³•2ï¼šä½¿ç”¨ Future**

```java
ExecutorService pool = Executors.newFixedThreadPool(1);
Future<Boolean> f = pool.submit(() -> {
    log.debug("task1");
    int i = 1 / 0;
    return true;
});
log.debug("result:{}", f.get());
```



#### 10. å®šæ—¶ä»»åŠ¡ ğŸ’¦

å¦‚ä½•è®©æ¯å‘¨å›› 18:00:00 å®šæ—¶æ‰§è¡Œä»»åŠ¡ï¼Ÿ

```java
public class TestSchedule {

    // å¦‚ä½•è®©æ¯å‘¨å›› 18:00:00 å®šæ—¶æ‰§è¡Œä»»åŠ¡ï¼Ÿ
    public static void main(String[] args) {
        //  è·å–å½“å‰æ—¶é—´
        LocalDateTime now = LocalDateTime.now();
        System.out.println(now);
        // è·å–å‘¨å››æ—¶é—´
        LocalDateTime time = now.withHour(18).withMinute(0).withSecond(0).withNano(0).with(DayOfWeek.THURSDAY);
        // å¦‚æœ å½“å‰æ—¶é—´ > æœ¬å‘¨å‘¨å››ï¼Œå¿…é¡»æ‰¾åˆ°ä¸‹å‘¨å‘¨å››
        if(now.compareTo(time) > 0) {
            time = time.plusWeeks(1);
        }
        System.out.println(time);
        // initailDelay ä»£è¡¨å½“å‰æ—¶é—´å’Œå‘¨å››çš„æ—¶é—´å·®
        // period ä¸€å‘¨çš„é—´éš”æ—¶é—´
        long initailDelay = Duration.between(now, time).toMillis();
        long period = 1000 * 60 * 60 * 24 * 7;
        ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);
        pool.scheduleAtFixedRate(() -> {
            System.out.println("running...");
        }, initailDelay, period, TimeUnit.MILLISECONDS);
    }
}
```





#### 11. Tomcat çº¿ç¨‹æ± 

Tomcat åœ¨å“ªé‡Œç”¨åˆ°äº†çº¿ç¨‹æ± å‘¢

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192111786.png)

- LimitLatch ç”¨æ¥é™æµï¼Œå¯ä»¥æ§åˆ¶æœ€å¤§è¿æ¥ä¸ªæ•°ï¼Œç±»ä¼¼ J.U.C ä¸­çš„ Semaphore åé¢å†è®²
- Acceptor åªè´Ÿè´£ã€æ¥æ”¶æ–°çš„ socket è¿æ¥ã€‘
- Poller åªè´Ÿè´£ç›‘å¬ socket channel æ˜¯å¦æœ‰ã€å¯è¯»çš„ I/O äº‹ä»¶ã€‘
- ä¸€æ—¦å¯è¯»ï¼Œå°è£…ä¸€ä¸ªä»»åŠ¡å¯¹è±¡ï¼ˆsocketProcessorï¼‰ï¼Œæäº¤ç»™ Executor çº¿ç¨‹æ± å¤„ç†
- Executor çº¿ç¨‹æ± ä¸­çš„å·¥ä½œçº¿ç¨‹æœ€ç»ˆè´Ÿè´£ã€å¤„ç†è¯·æ±‚ã€‘

Tomcat çº¿ç¨‹æ± æ‰©å±•äº† ThreadPoolExecutorï¼Œè¡Œä¸ºç¨æœ‰ä¸åŒ

- å¦‚æœæ€»çº¿ç¨‹æ•°è¾¾åˆ° maximumPoolSize
  - è¿™æ—¶ä¸ä¼šç«‹åˆ»æŠ› RejectedExecutionException å¼‚å¸¸
  - è€Œæ˜¯å†æ¬¡å°è¯•å°†ä»»åŠ¡æ”¾å…¥é˜Ÿåˆ—ï¼Œå¦‚æœè¿˜å¤±è´¥ï¼Œæ‰æŠ›å‡º RejectedExecutionException å¼‚å¸¸

æºç  tomcat-7.0.42

```java
public void execute(Runnable command, long timeout, TimeUnit unit) {
    submittedCount.incrementAndGet();
    try {
        super.execute(command);
    } catch (RejectedExecutionException rx) {
        if (super.getQueue() instanceof TaskQueue) {
            final TaskQueue queue = (TaskQueue)super.getQueue();
            try {
                if (!queue.force(command, timeout, unit)) {
                    submittedCount.decrementAndGet();
                    throw new RejectedExecutionException("Queue capacity is full.");
                }
            } catch (InterruptedException x) {
                submittedCount.decrementAndGet();
                Thread.interrupted();
                throw new RejectedExecutionException(x);
            }
        } else {
            submittedCount.decrementAndGet();
            throw rx;
        }
    }
}

```

TaskQueue.java

```java
public boolean force(Runnable o, long timeout, TimeUnit unit) throws InterruptedException {
    if ( parent.isShutdown() ) 
        throw new RejectedExecutionException(
        "Executor not running, can't force a command into the queue"
    );
    return super.offer(o,timeout,unit); //forces the item onto the queue, to be used if the task 
    is rejected
}
```



**Connector é…ç½®**

| é…ç½®é¡¹                | é»˜è®¤å€¼ | è¯´æ˜                                   |
| --------------------- | ------ | -------------------------------------- |
| `acceptorThreadCount` | 1      | acceptor çº¿ç¨‹æ•°é‡                      |
| `pollerThreadCount`   | 1      | poller çº¿ç¨‹æ•°é‡                        |
| `minSpareThreads`     | 10     | æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œå³ corePoolSize            |
| `maxThreads`          | 200    | æœ€å¤§çº¿ç¨‹æ•°ï¼Œå³ maximumPoolSize         |
| `executor`            | -      | Executor åç§°ï¼Œç”¨æ¥å¼•ç”¨ä¸‹é¢çš„ Executor |



**Executor çº¿ç¨‹é…ç½®**

| é…ç½®é¡¹                    | é»˜è®¤å€¼               | è¯´æ˜                                      |
| ------------------------- | -------------------- | ----------------------------------------- |
| `threadPriority`          | 2                    | çº¿ç¨‹ä¼˜å…ˆçº§                                |
| `daemon`                  | true                 | æ˜¯å¦å®ˆæŠ¤çº¿ç¨‹                              |
| `minSpareThreads `        | 25                   | æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œå³ corePoolSize               |
| `maxThreads`              | 200                  | æœ€å¤§çº¿ç¨‹æ•°ï¼Œå³ maximumPoolSize            |
| `maxIdleTime`             | 60000                | çº¿ç¨‹ç”Ÿå­˜æ—¶é—´ï¼Œå•ä½æ˜¯æ¯«ç§’ï¼Œé»˜è®¤å€¼å³ 1 åˆ†é’Ÿ |
| `maxQueueSize`            | `Integer.MAX_VALUE ` | é˜Ÿåˆ—é•¿åº¦                                  |
| `prestartminSpareThreads` | false                | æ ¸å¿ƒçº¿ç¨‹æ˜¯å¦åœ¨æœåŠ¡å™¨å¯åŠ¨æ—¶å¯åŠ¨            |

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192112277.png)





### 3. å¼‚æ­¥æ¨¡å¼ä¹‹å·¥ä½œçº¿ç¨‹ ğŸ

#### 1. å®šä¹‰

è®©æœ‰é™çš„å·¥ä½œçº¿ç¨‹ï¼ˆWorker Threadï¼‰æ¥è½®æµå¼‚æ­¥å¤„ç†æ— é™å¤šçš„ä»»åŠ¡ã€‚ä¹Ÿå¯ä»¥å°†å…¶å½’ç±»ä¸ºåˆ†å·¥æ¨¡å¼ï¼Œå®ƒçš„å…¸å‹å®ç° å°±æ˜¯çº¿ç¨‹æ± ï¼Œä¹Ÿä½“ç°äº†ç»å…¸è®¾è®¡æ¨¡å¼ä¸­çš„äº«å…ƒæ¨¡å¼ã€‚

ä¾‹å¦‚ï¼Œæµ·åº•æçš„æœåŠ¡å‘˜ï¼ˆçº¿ç¨‹ï¼‰ï¼Œè½®æµå¤„ç†æ¯ä½å®¢äººçš„ç‚¹é¤ï¼ˆä»»åŠ¡ï¼‰ï¼Œå¦‚æœä¸ºæ¯ä½å®¢äººéƒ½é…ä¸€åä¸“å±çš„æœåŠ¡å‘˜ï¼Œé‚£ ä¹ˆæˆæœ¬å°±å¤ªé«˜äº†ï¼ˆå¯¹æ¯”å¦ä¸€ç§å¤šçº¿ç¨‹è®¾è®¡æ¨¡å¼ï¼šThread-Per-Messageï¼‰

æ³¨æ„ï¼Œä¸åŒä»»åŠ¡ç±»å‹åº”è¯¥ä½¿ç”¨ä¸åŒçš„çº¿ç¨‹æ± ï¼Œè¿™æ ·èƒ½å¤Ÿé¿å…é¥¥é¥¿ï¼Œå¹¶èƒ½æå‡æ•ˆç‡

ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªé¤é¦†çš„å·¥äººæ—¢è¦æ‹›å‘¼å®¢äººï¼ˆä»»åŠ¡ç±»å‹Aï¼‰ï¼Œåˆè¦åˆ°åå¨åšèœï¼ˆä»»åŠ¡ç±»å‹Bï¼‰æ˜¾ç„¶æ•ˆç‡ä¸å’‹åœ°ï¼Œåˆ†æˆ æœåŠ¡å‘˜ï¼ˆçº¿ç¨‹æ± Aï¼‰ä¸å¨å¸ˆï¼ˆçº¿ç¨‹æ± Bï¼‰æ›´ä¸ºåˆç†ï¼Œå½“ç„¶ä½ èƒ½æƒ³åˆ°æ›´ç»†è‡´çš„åˆ†å·¥





#### 2. é¥¥é¥¿

å›ºå®šå¤§å°çº¿ç¨‹æ± ä¼šæœ‰é¥¥é¥¿ç°è±¡

- ä¸¤ä¸ªå·¥äººæ˜¯åŒä¸€ä¸ªçº¿ç¨‹æ± ä¸­çš„ä¸¤ä¸ªçº¿ç¨‹
- ä»–ä»¬è¦åšçš„äº‹æƒ…æ˜¯ï¼šä¸ºå®¢äººç‚¹é¤å’Œåˆ°åå¨åšèœï¼Œè¿™æ˜¯ä¸¤ä¸ªé˜¶æ®µçš„å·¥ä½œ
  - å®¢äººç‚¹é¤ï¼šå¿…é¡»å…ˆç‚¹å®Œé¤ï¼Œç­‰èœåšå¥½ï¼Œä¸Šèœï¼Œåœ¨æ­¤æœŸé—´å¤„ç†ç‚¹é¤çš„å·¥äººå¿…é¡»ç­‰å¾…
  - åå¨åšèœï¼šæ²¡å•¥è¯´çš„ï¼Œåšå°±æ˜¯äº†

- æ¯”å¦‚å·¥äººA å¤„ç†äº†ç‚¹é¤ä»»åŠ¡ï¼Œæ¥ä¸‹æ¥å®ƒè¦ç­‰ç€ å·¥äººB æŠŠèœåšå¥½ï¼Œç„¶åä¸Šèœï¼Œä»–ä¿©ä¹Ÿé…åˆçš„è›®å¥½
- ä½†ç°åœ¨åŒæ—¶æ¥äº†ä¸¤ä¸ªå®¢äººï¼Œè¿™ä¸ªæ—¶å€™å·¥äººA å’Œå·¥äººB éƒ½å»å¤„ç†ç‚¹é¤äº†ï¼Œè¿™æ—¶æ²¡äººåšé¥­äº†ï¼Œé¥¥é¥¿

```java
public class TestStarvation {
    static final List<String> MENU = Arrays.asList("åœ°ä¸‰é²œ", "å®«ä¿é¸¡ä¸", "è¾£å­é¸¡ä¸", "çƒ¤é¸¡ç¿…");
    static Random RANDOM = new Random();

    static String cooking() {
        return MENU.get(RANDOM.nextInt(MENU.size()));
    }

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        executorService.execute(() -> {
            log.debug("å¤„ç†ç‚¹é¤...");
            Future<String> f = executorService.submit(() -> {
                log.debug("åšèœ");
                return cooking();
            });
            try {
                log.debug("ä¸Šèœ: {}", f.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
//        executorService.execute(() -> {
//            log.debug("å¤„ç†ç‚¹é¤...");
//            Future<String> f = executorService.submit(() -> {
//                log.debug("åšèœ");
//                return cooking();
//            });
//            try {
//                log.debug("ä¸Šèœ: {}", f.get());
//            } catch (InterruptedException | ExecutionException e) {
//
//                e.printStackTrace();
//            }
//        });
    }
}
```

```shell
# ç»“æœ
# æœ‰æ³¨é‡Š
12:53:38.922 c.TestDeadLock [pool-1-thread-1] - å¤„ç†ç‚¹é¤...
12:53:38.930 c.TestDeadLock [pool-1-thread-2] - åšèœ
12:53:38.931 c.TestDeadLock [pool-1-thread-1] - ä¸Šèœ: åœ°ä¸‰é²œ

# æ²¡æ³¨é‡Š
12:55:06.855 c.TestDeadLock [pool-1-thread-1] - å¤„ç†ç‚¹é¤...
12:55:06.910 c.TestDeadLock [pool-1-thread-2] - å¤„ç†ç‚¹é¤...
```

è§£å†³æ–¹æ³•å¯ä»¥å¢åŠ çº¿ç¨‹æ± çš„å¤§å°ï¼Œä¸è¿‡ä¸æ˜¯æ ¹æœ¬è§£å†³æ–¹æ¡ˆï¼Œè¿˜æ˜¯å‰é¢æåˆ°çš„ï¼Œä¸åŒçš„ä»»åŠ¡ç±»å‹ï¼Œé‡‡ç”¨ä¸åŒçš„çº¿ç¨‹ æ± ï¼Œä¾‹å¦‚ï¼š

```java
public class TestStarvation {

    static final List<String> MENU = Arrays.asList("åœ°ä¸‰é²œ", "å®«ä¿é¸¡ä¸", "è¾£å­é¸¡ä¸", "çƒ¤é¸¡ç¿…");
    static Random RANDOM = new Random();

    static String cooking() {
        return MENU.get(RANDOM.nextInt(MENU.size()));
    }

    public static void main(String[] args) {
        ExecutorService waiterPool = Executors.newFixedThreadPool(1);
        ExecutorService cookPool = Executors.newFixedThreadPool(1);

        waiterPool.execute(() -> {
            log.debug("å¤„ç†ç‚¹é¤...");
            Future<String> f = cookPool.submit(() -> {
                log.debug("åšèœ");
                return cooking();
            });
            try {
                log.debug("ä¸Šèœ: {}", f.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
        waiterPool.execute(() -> {
            log.debug("å¤„ç†ç‚¹é¤...");
            Future<String> f = cookPool.submit(() -> {
                log.debug("åšèœ");
                return cooking();
            });
            try {
                log.debug("ä¸Šèœ: {}", f.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
    }
}
```

```shell
# ç»“æœ
12:56:27.751 c.TestDeadLock [pool-1-thread-1] - å¤„ç†ç‚¹é¤...
12:56:27.778 c.TestDeadLock [pool-2-thread-1] - åšèœ
12:56:27.779 c.TestDeadLock [pool-1-thread-1] - ä¸Šèœ: è¾£å­é¸¡ä¸
12:56:27.785 c.TestDeadLock [pool-1-thread-1] - å¤„ç†ç‚¹é¤...
12:56:27.786 c.TestDeadLock [pool-2-thread-1] - åšèœ
12:56:27.786 c.TestDeadLock [pool-1-thread-1] - ä¸Šèœ: è¾£å­é¸¡ä¸
```





#### 3.  åˆ›å»ºå¤šå°‘çº¿ç¨‹æ± åˆé€‚

- è¿‡å°ä¼šå¯¼è‡´ç¨‹åºä¸èƒ½å……åˆ†åœ°åˆ©ç”¨ç³»ç»Ÿèµ„æºã€å®¹æ˜“å¯¼è‡´é¥¥é¥¿
- è¿‡å¤§ä¼šå¯¼è‡´æ›´å¤šçš„çº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œå ç”¨æ›´å¤šå†…å­˜



##### 1. CPU å¯†é›†å‹è¿ç®—

é€šå¸¸é‡‡ç”¨ `cpu æ ¸æ•° + 1` èƒ½å¤Ÿå®ç°æœ€ä¼˜çš„ CPU åˆ©ç”¨ç‡ï¼Œ+1 æ˜¯ä¿è¯å½“çº¿ç¨‹ç”±äºé¡µç¼ºå¤±æ•…éšœï¼ˆæ“ä½œç³»ç»Ÿï¼‰æˆ–å…¶å®ƒåŸå›  å¯¼è‡´æš‚åœæ—¶ï¼Œé¢å¤–çš„è¿™ä¸ªçº¿ç¨‹å°±èƒ½é¡¶ä¸Šå»ï¼Œä¿è¯ CPU æ—¶é’Ÿå‘¨æœŸä¸è¢«æµªè´¹



##### 2. I/O å¯†é›†å‹è¿ç®—

CPU ä¸æ€»æ˜¯å¤„äºç¹å¿™çŠ¶æ€ï¼Œä¾‹å¦‚ï¼Œå½“ä½ æ‰§è¡Œä¸šåŠ¡è®¡ç®—æ—¶ï¼Œè¿™æ—¶å€™ä¼šä½¿ç”¨ CPU èµ„æºï¼Œä½†å½“ä½ æ‰§è¡Œ I/O æ“ä½œæ—¶ã€è¿œç¨‹ RPC è°ƒç”¨æ—¶ï¼ŒåŒ…æ‹¬è¿›è¡Œæ•°æ®åº“æ“ä½œæ—¶ï¼Œè¿™æ—¶å€™ CPU å°±é—²ä¸‹æ¥äº†ï¼Œä½ å¯ä»¥åˆ©ç”¨å¤šçº¿ç¨‹æé«˜å®ƒçš„åˆ©ç”¨ç‡ã€‚

ç»éªŒå…¬å¼å¦‚ä¸‹

`çº¿ç¨‹æ•° = æ ¸æ•° * æœŸæœ› CPU åˆ©ç”¨ç‡ * æ€»æ—¶é—´(CPUè®¡ç®—æ—¶é—´+ç­‰å¾…æ—¶é—´) / CPU è®¡ç®—æ—¶é—´`

ä¾‹å¦‚ 4 æ ¸ CPU è®¡ç®—æ—¶é—´æ˜¯ 50% ï¼Œå…¶å®ƒç­‰å¾…æ—¶é—´æ˜¯ 50%ï¼ŒæœŸæœ› cpu è¢« 100% åˆ©ç”¨ï¼Œå¥—ç”¨å…¬å¼

`4 * 100% * 100% / 50% = 8`

ä¾‹å¦‚ 4 æ ¸ CPU è®¡ç®—æ—¶é—´æ˜¯ 10% ï¼Œå…¶å®ƒç­‰å¾…æ—¶é—´æ˜¯ 90%ï¼ŒæœŸæœ› cpu è¢« 100% åˆ©ç”¨ï¼Œå¥—ç”¨å…¬å¼

`4 * 100% * 100% / 10% = 40`





#### 4. è‡ªå®šä¹‰çº¿ç¨‹æ± 

> ä¸Šé¢æœ‰è®² ğŸ‘†





### 4. Fork/Join

#### 1. æ¦‚å¿µ

Fork/Join æ˜¯ JDK 1.7 åŠ å…¥çš„æ–°çš„çº¿ç¨‹æ± å®ç°ï¼Œå®ƒä½“ç°çš„æ˜¯ä¸€ç§åˆ†æ²»æ€æƒ³ï¼Œé€‚ç”¨äºèƒ½å¤Ÿè¿›è¡Œä»»åŠ¡æ‹†åˆ†çš„ cpu å¯†é›†å‹ è¿ç®—

æ‰€è°“çš„ä»»åŠ¡æ‹†åˆ†ï¼Œæ˜¯å°†ä¸€ä¸ªå¤§ä»»åŠ¡æ‹†åˆ†ä¸ºç®—æ³•ä¸Šç›¸åŒçš„å°ä»»åŠ¡ï¼Œç›´è‡³ä¸èƒ½æ‹†åˆ†å¯ä»¥ç›´æ¥æ±‚è§£ã€‚è·Ÿé€’å½’ç›¸å…³çš„ä¸€äº›è®¡ ç®—ï¼Œå¦‚å½’å¹¶æ’åºã€æ–æ³¢é‚£å¥‘æ•°åˆ—ã€éƒ½å¯ä»¥ç”¨åˆ†æ²»æ€æƒ³è¿›è¡Œæ±‚è§£

Fork/Join åœ¨åˆ†æ²»çš„åŸºç¡€ä¸ŠåŠ å…¥äº†å¤šçº¿ç¨‹ï¼Œå¯ä»¥æŠŠæ¯ä¸ªä»»åŠ¡çš„åˆ†è§£å’Œåˆå¹¶äº¤ç»™ä¸åŒçš„çº¿ç¨‹æ¥å®Œæˆï¼Œè¿›ä¸€æ­¥æå‡äº†è¿ ç®—æ•ˆç‡

Fork/Join é»˜è®¤ä¼šåˆ›å»ºä¸ cpu æ ¸å¿ƒæ•°å¤§å°ç›¸åŒçš„çº¿ç¨‹æ± 



#### 2. ä½¿ç”¨

æäº¤ç»™ Fork/Join çº¿ç¨‹æ± çš„ä»»åŠ¡éœ€è¦ç»§æ‰¿ RecursiveTaskï¼ˆæœ‰è¿”å›å€¼ï¼‰æˆ– RecursiveActionï¼ˆæ²¡æœ‰è¿”å›å€¼ï¼‰ï¼Œä¾‹å¦‚ä¸‹ é¢å®šä¹‰äº†ä¸€ä¸ªå¯¹ 1~n ä¹‹é—´çš„æ•´æ•°æ±‚å’Œçš„ä»»åŠ¡

```java
class AddTask1 extends RecursiveTask<Integer> {
    int n;
    
    public AddTask1(int n) {
        this.n = n;
    }
    
    @Override
    public String toString() {
        return "{" + n + '}';
    }
    
    @Override
    protected Integer compute() {
        // å¦‚æœ n å·²ç»ä¸º 1ï¼Œå¯ä»¥æ±‚å¾—ç»“æœäº†
        if (n == 1) {
            log.debug("join() {}", n);
            return n;
        }

        // å°†ä»»åŠ¡è¿›è¡Œæ‹†åˆ†(fork)
        AddTask1 t1 = new AddTask1(n - 1);
        t1.fork();
        log.debug("fork() {} + {}", n, t1);

        // åˆå¹¶(join)ç»“æœ
        int result = n + t1.join();
        log.debug("join() {} + {} = {}", n, t1, result);
        return result;
    }
}
```

ç„¶åæäº¤ç»™ ForkJoinPool æ¥æ‰§è¡Œ

```java
public static void main(String[] args) {
    ForkJoinPool pool = new ForkJoinPool(4);
    System.out.println(pool.invoke(new AddTask1(5)));
}
```

å¹¶è¡Œåº¦å¹¶ä¸é«˜ï¼Œåä¸€æ­¥ä¾èµ–äºä¸Šä¸€æ­¥çš„ç»“æœï¼Œå¦‚å›¾ï¼š

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192112058.png)



æ”¹è¿›

```java
lass AddTask3 extends RecursiveTask<Integer> {

    int begin;
    int end;

    public AddTask3(int begin, int end) {
        this.begin = begin;
        this.end = end;
    }

    @Override
    public String toString() {
        return "{" + begin + "," + end + '}';
    }

    @Override
    protected Integer compute() {
        if (begin == end) {
            log.debug("join() {}", begin);
            return begin;
        }
        if (end - begin == 1) {
            log.debug("join() {} + {} = {}", begin, end, end + begin);
            return end + begin;
        }
        int mid = (end + begin) / 2;

        AddTask3 t1 = new AddTask3(begin, mid);
        t1.fork();
        AddTask3 t2 = new AddTask3(mid + 1, end);
        t2.fork();
        log.debug("fork() {} + {} = ?", t1, t2);

        int result = t1.join() + t2.join();
        log.debug("join() {} + {} = {}", t1, t2, result);
        return result;
    }
}
```

```java
public static void main(String[] args) {
    ForkJoinPool pool = new ForkJoinPool(4);
    System.out.println(pool.invoke(new AddTask3(1, 10)));
}
```

ç”¨å›¾æ¥è¡¨ç¤º

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192112055.png)







## 2. JUC

### 1. AQS åŸç†

#### 1. æ¦‚è¿°

å…¨ç§°æ˜¯ AbstractQueuedSynchronizerï¼Œæ˜¯é˜»å¡å¼é”å’Œç›¸å…³çš„åŒæ­¥å™¨å·¥å…·çš„æ¡†æ¶

**ç‰¹ç‚¹ï¼š**

- ç”¨ state å±æ€§æ¥è¡¨ç¤ºèµ„æºçš„çŠ¶æ€ï¼ˆåˆ†ç‹¬å æ¨¡å¼å’Œå…±äº«æ¨¡å¼ï¼‰ï¼Œå­ç±»éœ€è¦å®šä¹‰å¦‚ä½•ç»´æŠ¤è¿™ä¸ªçŠ¶æ€ï¼Œæ§åˆ¶å¦‚ä½•è·å– é”å’Œé‡Šæ”¾é”
  - getState - è·å–state çŠ¶æ€
  - setState - è®¾ç½® state çŠ¶æ€
  - compareAndSetState - cas æœºåˆ¶è®¾ç½® state çŠ¶æ€
  - ç‹¬å æ¨¡å¼æ˜¯åªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½å¤Ÿè®¿é—®èµ„æºï¼Œè€Œå…±äº«æ¨¡å¼å¯ä»¥å…è®¸å¤šä¸ªçº¿ç¨‹è®¿é—®èµ„æº

- æä¾›äº†åŸºäº FIFO çš„ç­‰å¾…é˜Ÿåˆ—ï¼Œç±»ä¼¼äº Monitor çš„ EntryList
- æ¡ä»¶å˜é‡æ¥å®ç°ç­‰å¾…ã€å”¤é†’æœºåˆ¶ï¼Œæ”¯æŒå¤šä¸ªæ¡ä»¶å˜é‡ï¼Œç±»ä¼¼äº Monitor çš„ WaitSet

å­ç±»ä¸»è¦å®ç°è¿™æ ·ä¸€äº›æ–¹æ³•ï¼ˆé»˜è®¤æŠ›å‡º UnsupportedOperationExceptionï¼‰

- tryAcquire
- tryRelease
- tryAcquireShared
- tryReleaseShared
- isHeldExclusively



è·å–é”çš„å§¿åŠ¿

```java
// å¦‚æœè·å–é”å¤±è´¥
if (!tryAcquire(arg)) {
    // å…¥é˜Ÿ, å¯ä»¥é€‰æ‹©é˜»å¡å½“å‰çº¿ç¨‹ park unpark
}
```

é‡Šæ”¾é”çš„å§¿åŠ¿

```java
// å¦‚æœé‡Šæ”¾é”æˆåŠŸ
if (tryRelease(arg)) {
    // è®©é˜»å¡çº¿ç¨‹æ¢å¤è¿è¡Œ
}
```





#### 2. å®ç°ä¸å¯é‡å…¥é”

```java
// è‡ªå®šä¹‰é”ï¼ˆä¸å¯é‡å…¥é”ï¼‰
class MyLock implements Lock {

    private MySync sync = new MySync();

    @Override // åŠ é”ï¼ˆä¸æˆåŠŸä¼šè¿›å…¥ç­‰å¾…é˜Ÿåˆ—ï¼‰
    public void lock() {
        sync.acquire(1);
    }

    @Override // åŠ é”ï¼Œå¯æ‰“æ–­
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }

    @Override // å°è¯•åŠ é”ï¼ˆä¸€æ¬¡ï¼‰
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    @Override // å°è¯•åŠ é”ï¼Œå¸¦è¶…æ—¶
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireNanos(1, unit.toNanos(time));
    }

    @Override // è§£é”
    public void unlock() {
        sync.release(1);
    }

    @Override // åˆ›å»ºæ¡ä»¶å˜é‡
    public Condition newCondition() {
        return sync.newCondition();
    }

    // ç‹¬å é”  åŒæ­¥å™¨ç±»
    class MySync extends AbstractQueuedSynchronizer {
        @Override
        protected boolean tryAcquire(int arg) {
            if(compareAndSetState(0, 1)) {
                // åŠ ä¸Šäº†é”ï¼Œå¹¶è®¾ç½® owner ä¸ºå½“å‰çº¿ç¨‹
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        @Override
        protected boolean tryRelease(int arg) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }

        @Override // æ˜¯å¦æŒæœ‰ç‹¬å é”
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }

        public Condition newCondition() {
            return new ConditionObject();
        }
    }
}
```

æµ‹è¯•

```java
public class TestAqs {
    public static void main(String[] args) {
        MyLock lock = new MyLock();
        new Thread(() -> {
            lock.lock();
            try {
                log.debug("locking...");
                sleep(3);
            } finally {
                log.debug("unlocking...");
                lock.unlock();
            }
        },"t1").start();

        new Thread(() -> {
            lock.lock();
            try {
                log.debug("locking...");
            } finally {
                log.debug("unlocking...");
                lock.unlock();
            }
        },"t2").start();
    }
}
```

ä¸å¯é‡å…¥æµ‹è¯•

å¦‚æœæ”¹ä¸ºä¸‹é¢ä»£ç ï¼Œä¼šå‘ç°è‡ªå·±ä¹Ÿä¼šè¢«æŒ¡ä½ï¼ˆåªä¼šæ‰“å°ä¸€æ¬¡ lockingï¼‰

```java
lock.lock();
log.debug("locking...");
lock.lock();
log.debug("locking...");
```





#### 3. å¿ƒå¾—

**èµ·æº**

æ—©æœŸç¨‹åºå‘˜ä¼šè‡ªå·±é€šè¿‡ä¸€ç§åŒæ­¥å™¨å»å®ç°å¦ä¸€ç§ç›¸è¿‘çš„åŒæ­¥å™¨ï¼Œä¾‹å¦‚ç”¨å¯é‡å…¥é”å»å®ç°ä¿¡å·é‡ï¼Œæˆ–åä¹‹ã€‚è¿™æ˜¾ç„¶ä¸ å¤Ÿä¼˜é›…ï¼Œäºæ˜¯åœ¨ JSR166ï¼ˆjava è§„èŒƒææ¡ˆï¼‰ä¸­åˆ›å»ºäº† AQSï¼Œæä¾›äº†è¿™ç§é€šç”¨çš„åŒæ­¥å™¨æœºåˆ¶ã€‚

**ç›®æ ‡**

AQS è¦å®ç°çš„åŠŸèƒ½ç›®æ ‡

- é˜»å¡ç‰ˆæœ¬è·å–é” acquire å’Œéé˜»å¡çš„ç‰ˆæœ¬å°è¯•è·å–é” tryAcquire
- è·å–é”è¶…æ—¶æœºåˆ¶
- é€šè¿‡æ‰“æ–­å–æ¶ˆæœºåˆ¶
- ç‹¬å æœºåˆ¶åŠå…±äº«æœºåˆ¶
- æ¡ä»¶ä¸æ»¡è¶³æ—¶çš„ç­‰å¾…æœºåˆ¶

è¦å®ç°çš„æ€§èƒ½ç›®æ ‡

> Instead, the primary performance goal here is scalability: to predictably maintain efficiency even, or especially, when synchronizers are contended.

**è®¾è®¡**

AQS çš„åŸºæœ¬æ€æƒ³å…¶å®å¾ˆç®€å•

è·å–é”çš„é€»è¾‘

```java
while(state çŠ¶æ€ä¸å…è®¸è·å–) {
    if(é˜Ÿåˆ—ä¸­è¿˜æ²¡æœ‰æ­¤çº¿ç¨‹) {
        å…¥é˜Ÿå¹¶é˜»å¡
    }
}
å½“å‰çº¿ç¨‹å‡ºé˜Ÿ
```

é‡Šæ”¾é”çš„é€»è¾‘

```java
if(state çŠ¶æ€å…è®¸äº†) {
    æ¢å¤é˜»å¡çš„çº¿ç¨‹(s)
}
```



**è¦ç‚¹**

- åŸå­ç»´æŠ¤ state çŠ¶æ€
- é˜»å¡åŠæ¢å¤çº¿ç¨‹
- ç»´æŠ¤é˜Ÿåˆ—

**1. state è®¾è®¡**

- state ä½¿ç”¨ volatile é…åˆ cas ä¿è¯å…¶ä¿®æ”¹æ—¶çš„åŸå­æ€§
- state ä½¿ç”¨äº† 32bit int æ¥ç»´æŠ¤åŒæ­¥çŠ¶æ€ï¼Œå› ä¸ºå½“æ—¶ä½¿ç”¨ long åœ¨å¾ˆå¤šå¹³å°ä¸‹æµ‹è¯•çš„ç»“æœå¹¶ä¸ç†æƒ³

**2. é˜»å¡æ¢å¤è®¾è®¡**

- æ—©æœŸçš„æ§åˆ¶çº¿ç¨‹æš‚åœå’Œæ¢å¤çš„ api æœ‰ suspend å’Œ resumeï¼Œä½†å®ƒä»¬æ˜¯ä¸å¯ç”¨çš„ï¼Œå› ä¸ºå¦‚æœå…ˆè°ƒç”¨çš„ resume  é‚£ä¹ˆ suspend å°†æ„ŸçŸ¥ä¸åˆ°
- è§£å†³æ–¹æ³•æ˜¯ä½¿ç”¨ park & unpark æ¥å®ç°çº¿ç¨‹çš„æš‚åœå’Œæ¢å¤ï¼Œå…·ä½“åŸç†åœ¨ä¹‹å‰è®²è¿‡äº†ï¼Œå…ˆ unpark å† park ä¹Ÿæ²¡ é—®é¢˜
- park & unpark æ˜¯é’ˆå¯¹çº¿ç¨‹çš„ï¼Œè€Œä¸æ˜¯é’ˆå¯¹åŒæ­¥å™¨çš„ï¼Œå› æ­¤æ§åˆ¶ç²’åº¦æ›´ä¸ºç²¾ç»†
- park çº¿ç¨‹è¿˜å¯ä»¥é€šè¿‡ interrupt æ‰“æ–­

**3. é˜Ÿåˆ—è®¾è®¡**

- ä½¿ç”¨äº† FIFO å…ˆå…¥å…ˆå‡ºé˜Ÿåˆ—ï¼Œå¹¶ä¸æ”¯æŒä¼˜å…ˆçº§é˜Ÿåˆ—
- è®¾è®¡æ—¶å€Ÿé‰´äº† CLH é˜Ÿåˆ—ï¼Œå®ƒæ˜¯ä¸€ç§å•å‘æ— é”é˜Ÿåˆ—

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192113772.png)

é˜Ÿåˆ—ä¸­æœ‰ head å’Œ tail ä¸¤ä¸ªæŒ‡é’ˆèŠ‚ç‚¹ï¼Œéƒ½ç”¨ volatile ä¿®é¥°é…åˆ cas ä½¿ç”¨ï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ‰ state ç»´æŠ¤èŠ‚ç‚¹çŠ¶æ€ å…¥é˜Ÿä¼ªä»£ç ï¼Œåªéœ€è¦è€ƒè™‘ tail èµ‹å€¼çš„åŸå­æ€§

```java
do {
    // åŸæ¥çš„ tail
    Node prev = tail;
    // ç”¨ cas åœ¨åŸæ¥ tail çš„åŸºç¡€ä¸Šæ”¹ä¸º node
} while(tail.compareAndSet(prev, node))
```

å‡ºé˜Ÿä¼ªä»£ç 

```java
// prev æ˜¯ä¸Šä¸€ä¸ªèŠ‚ç‚¹
while((Node prev=node.prev).state != å”¤é†’çŠ¶æ€) {
}
// è®¾ç½®å¤´èŠ‚ç‚¹
head = node;
```

CLH å¥½å¤„ï¼š

- æ— é”ï¼Œä½¿ç”¨è‡ªæ—‹
- å¿«é€Ÿï¼Œæ— é˜»å¡

AQS åœ¨ä¸€äº›æ–¹é¢æ”¹è¿›äº† CLH

```java
private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        // é˜Ÿåˆ—ä¸­è¿˜æ²¡æœ‰å…ƒç´  tail ä¸º null
        if (t == null) {
            // å°† head ä» null -> dummy
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            // å°† node çš„ prev è®¾ç½®ä¸ºåŸæ¥çš„ tail
            node.prev = t;
            // å°† tail ä»åŸæ¥çš„ tail è®¾ç½®ä¸º node
            if (compareAndSetTail(t, node)) {
                // åŸæ¥ tail çš„ next è®¾ç½®ä¸º node
                t.next = node;
                return t;
            }
        }
    }
}
```

ä¸»è¦ç”¨åˆ° AQS çš„å¹¶å‘å·¥å…·ç±»

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192113569.png)





### 2. ReentrantLock åŸç†

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192114212.png)

#### 1. éå…¬å¹³é”å®ç°åŸç†

##### 1. åŠ é”è§£é”æµç¨‹

å…ˆä»æ„é€ å™¨å¼€å§‹çœ‹ï¼Œé»˜è®¤ä¸ºéå…¬å¹³é”å®ç°

```java
public ReentrantLock() {
    sync = new NonfairSync();
}
```

NonfairSync ç»§æ‰¿è‡ª AQS

æ²¡æœ‰ç«äº‰æ—¶

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192114316.png)

ç¬¬ä¸€ä¸ªç«äº‰å‡ºç°æ—¶

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192114141.png)

Thread-1 æ‰§è¡Œäº†

1. CAS å°è¯•å°† state ç”± 0 æ”¹ä¸º 1ï¼Œç»“æœå¤±è´¥
2. è¿›å…¥ tryAcquire é€»è¾‘ï¼Œè¿™æ—¶ state å·²ç»æ˜¯1ï¼Œç»“æœä»ç„¶å¤±è´¥
3. æ¥ä¸‹æ¥è¿›å…¥ addWaiter é€»è¾‘ï¼Œæ„é€  Node é˜Ÿåˆ—
   - å›¾ä¸­é»„è‰²ä¸‰è§’è¡¨ç¤ºè¯¥ Node çš„ waitStatus çŠ¶æ€ï¼Œå…¶ä¸­ 0 ä¸ºé»˜è®¤æ­£å¸¸çŠ¶æ€
   - Node çš„åˆ›å»ºæ˜¯æ‡’æƒ°çš„
   - å…¶ä¸­ç¬¬ä¸€ä¸ª Node ç§°ä¸º Dummyï¼ˆå“‘å…ƒï¼‰æˆ–å“¨å…µï¼Œç”¨æ¥å ä½ï¼Œå¹¶ä¸å…³è”çº¿ç¨‹

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192114144.png)

å½“å‰çº¿ç¨‹è¿›å…¥ acquireQueued é€»è¾‘

1. acquireQueued ä¼šåœ¨ä¸€ä¸ªæ­»å¾ªç¯ä¸­ä¸æ–­å°è¯•è·å¾—é”ï¼Œå¤±è´¥åè¿›å…¥ park é˜»å¡
2. å¦‚æœè‡ªå·±æ˜¯ç´§é‚»ç€ headï¼ˆæ’ç¬¬äºŒä½ï¼‰ï¼Œé‚£ä¹ˆå†æ¬¡ tryAcquire å°è¯•è·å–é”ï¼Œå½“ç„¶è¿™æ—¶ state ä»ä¸º 1ï¼Œå¤±è´¥
3. è¿›å…¥ shouldParkAfterFailedAcquire é€»è¾‘ï¼Œå°†å‰é©± nodeï¼Œå³ head çš„ waitStatus æ”¹ä¸º -1ï¼Œè¿™æ¬¡è¿”å› false

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192115147.png)

4. shouldParkAfterFailedAcquire æ‰§è¡Œå®Œæ¯•å›åˆ° acquireQueued ï¼Œå†æ¬¡ tryAcquire å°è¯•è·å–é”ï¼Œå½“ç„¶è¿™æ—¶ state ä»ä¸º 1ï¼Œå¤±è´¥
5. å½“å†æ¬¡è¿›å…¥ shouldParkAfterFailedAcquire æ—¶ï¼Œè¿™æ—¶å› ä¸ºå…¶å‰é©± node çš„ waitStatus å·²ç»æ˜¯ -1ï¼Œè¿™æ¬¡è¿”å› true
6. è¿›å…¥ parkAndCheckInterruptï¼Œ Thread-1 parkï¼ˆç°è‰²è¡¨ç¤ºï¼‰

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192115943.png)

å†æ¬¡æœ‰å¤šä¸ªçº¿ç¨‹ç»å†ä¸Šè¿°è¿‡ç¨‹ç«äº‰å¤±è´¥ï¼Œå˜æˆè¿™ä¸ªæ ·å­

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192115320.png)

Thread-0 é‡Šæ”¾é”ï¼Œè¿›å…¥ tryRelease æµç¨‹ï¼Œå¦‚æœæˆåŠŸ

- è®¾ç½® exclusiveOwnerThread ä¸º null
- state = 0

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192115074.png)

å½“å‰é˜Ÿåˆ—ä¸ä¸º nullï¼Œå¹¶ä¸” head çš„ waitStatus = -1ï¼Œè¿›å…¥ unparkSuccessor æµç¨‹

æ‰¾åˆ°é˜Ÿåˆ—ä¸­ç¦» head æœ€è¿‘çš„ä¸€ä¸ª Nodeï¼ˆæ²¡å–æ¶ˆçš„ï¼‰ï¼Œunpark æ¢å¤å…¶è¿è¡Œï¼Œæœ¬ä¾‹ä¸­å³ä¸º Thread-1

å›åˆ° Thread-1 çš„ acquireQueued æµç¨‹

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192116932.png)

å¦‚æœåŠ é”æˆåŠŸï¼ˆæ²¡æœ‰ç«äº‰ï¼‰ï¼Œä¼šè®¾ç½®

- exclusiveOwnerThread ä¸º Thread-1ï¼Œstate = 1
- head æŒ‡å‘åˆšåˆš Thread-1 æ‰€åœ¨çš„ Nodeï¼Œè¯¥ Node æ¸…ç©º Thread
- åŸæœ¬çš„ head å› ä¸ºä»é“¾è¡¨æ–­å¼€ï¼Œè€Œå¯è¢«åƒåœ¾å›æ”¶

å¦‚æœè¿™æ—¶å€™æœ‰å…¶å®ƒçº¿ç¨‹æ¥ç«äº‰ï¼ˆéå…¬å¹³çš„ä½“ç°ï¼‰ï¼Œä¾‹å¦‚è¿™æ—¶æœ‰ Thread-4 æ¥äº†

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192116670.png)

å¦‚æœä¸å·§åˆè¢« Thread-4 å äº†å…ˆ

- Thread-4 è¢«è®¾ç½®ä¸º exclusiveOwnerThreadï¼Œstate = 1
- Thread-1 å†æ¬¡è¿›å…¥ acquireQueued æµç¨‹ï¼Œè·å–é”å¤±è´¥ï¼Œé‡æ–°è¿›å…¥ park é˜»å¡



##### 2. åŠ é”æºç 

```java
// Sync ç»§æ‰¿è‡ª AQS
static final class NonfairSync extends Sync {
    private static final long serialVersionUID = 7316153563782823691L;

    // åŠ é”å®ç°
    final void lock() {
        // é¦–å…ˆç”¨ cas å°è¯•ï¼ˆä»…å°è¯•ä¸€æ¬¡ï¼‰å°† state ä» 0 æ”¹ä¸º 1, å¦‚æœæˆåŠŸè¡¨ç¤ºè·å¾—äº†ç‹¬å é”
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            // å¦‚æœå°è¯•å¤±è´¥ï¼Œè¿›å…¥ ãˆ 
            acquire(1);
    }

    // ãˆ  AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    public final void acquire(int arg) {
        // ãˆ¡ tryAcquire 
        if (
            !tryAcquire(arg) &&
            // å½“ tryAcquire è¿”å›ä¸º false æ—¶, å…ˆè°ƒç”¨ addWaiter ãˆ£, æ¥ç€ acquireQueued ãˆ¤
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)
        ) {
            selfInterrupt();
        }
    }

    // ãˆ¡ è¿›å…¥ ãˆ¢
    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }

    // ãˆ¢ Sync ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        // å¦‚æœè¿˜æ²¡æœ‰è·å¾—é”
        if (c == 0) {
            // å°è¯•ç”¨ cas è·å¾—, è¿™é‡Œä½“ç°äº†éå…¬å¹³æ€§: ä¸å»æ£€æŸ¥ AQS é˜Ÿåˆ—
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        // å¦‚æœå·²ç»è·å¾—äº†é”, çº¿ç¨‹è¿˜æ˜¯å½“å‰çº¿ç¨‹, è¡¨ç¤ºå‘ç”Ÿäº†é”é‡å…¥
        else if (current == getExclusiveOwnerThread()) {
            // state++
            int nextc = c + acquires;
            if (nextc < 0) // overflow
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        // è·å–å¤±è´¥, å›åˆ°è°ƒç”¨å¤„
        return false;
    }

    // ãˆ£ AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    private Node addWaiter(Node mode) {
        // å°†å½“å‰çº¿ç¨‹å…³è”åˆ°ä¸€ä¸ª Node å¯¹è±¡ä¸Š, æ¨¡å¼ä¸ºç‹¬å æ¨¡å¼
        Node node = new Node(Thread.currentThread(), mode);
        // å¦‚æœ tail ä¸ä¸º null, cas å°è¯•å°† Node å¯¹è±¡åŠ å…¥ AQS é˜Ÿåˆ—å°¾éƒ¨
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                // åŒå‘é“¾è¡¨
                pred.next = node;
                return node;
            }
        }
        // å°è¯•å°† Node åŠ å…¥ AQS, è¿›å…¥ ãˆ¥
        enq(node);
        return node;
    }

    // ãˆ¥ AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) {
                // è¿˜æ²¡æœ‰, è®¾ç½® head ä¸ºå“¨å…µèŠ‚ç‚¹ï¼ˆä¸å¯¹åº”çº¿ç¨‹ï¼ŒçŠ¶æ€ä¸º 0ï¼‰
                if (compareAndSetHead(new Node())) {
                    tail = head;
                }
            } else {
                // cas å°è¯•å°† Node å¯¹è±¡åŠ å…¥ AQS é˜Ÿåˆ—å°¾éƒ¨
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }

    // ãˆ¤ AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                // ä¸Šä¸€ä¸ªèŠ‚ç‚¹æ˜¯ head, è¡¨ç¤ºè½®åˆ°è‡ªå·±ï¼ˆå½“å‰çº¿ç¨‹å¯¹åº”çš„ nodeï¼‰äº†, å°è¯•è·å–
                if (p == head && tryAcquire(arg)) {
                    // è·å–æˆåŠŸ, è®¾ç½®è‡ªå·±ï¼ˆå½“å‰çº¿ç¨‹å¯¹åº”çš„ nodeï¼‰ä¸º head
                    setHead(node);
                    // ä¸Šä¸€ä¸ªèŠ‚ç‚¹ help GC
                    p.next = null;
                    failed = false;
                    // è¿”å›ä¸­æ–­æ ‡è®° false
                    return interrupted;
                }
                if (
                    // åˆ¤æ–­æ˜¯å¦åº”å½“ park, è¿›å…¥ ãˆ¦
                    shouldParkAfterFailedAcquire(p, node) &&
                    // park ç­‰å¾…, æ­¤æ—¶ Node çš„çŠ¶æ€è¢«ç½®ä¸º Node.SIGNAL ãˆ§
                    parkAndCheckInterrupt()
                ) {
                    interrupted = true;
                }
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

    // ãˆ¦ AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        // è·å–ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„çŠ¶æ€
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL) {
            // ä¸Šä¸€ä¸ªèŠ‚ç‚¹éƒ½åœ¨é˜»å¡, é‚£ä¹ˆè‡ªå·±ä¹Ÿé˜»å¡å¥½äº†
            return true;
        }
        // > 0 è¡¨ç¤ºå–æ¶ˆçŠ¶æ€
        if (ws > 0) {
            // ä¸Šä¸€ä¸ªèŠ‚ç‚¹å–æ¶ˆ, é‚£ä¹ˆé‡æ„åˆ é™¤å‰é¢æ‰€æœ‰å–æ¶ˆçš„èŠ‚ç‚¹, è¿”å›åˆ°å¤–å±‚å¾ªç¯é‡è¯•
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus > 0);
            pred.next = node;
        } else {
            // è¿™æ¬¡è¿˜æ²¡æœ‰é˜»å¡
            // ä½†ä¸‹æ¬¡å¦‚æœé‡è¯•ä¸æˆåŠŸ, åˆ™éœ€è¦é˜»å¡ï¼Œè¿™æ—¶éœ€è¦è®¾ç½®ä¸Šä¸€ä¸ªèŠ‚ç‚¹çŠ¶æ€ä¸º Node.SIGNAL
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }

    // ãˆ§ é˜»å¡å½“å‰çº¿ç¨‹
    private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);
        return Thread.interrupted();
    }
}

```

> **æ³¨æ„**
>
> æ˜¯å¦éœ€è¦ unpark æ˜¯ç”±å½“å‰èŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹çš„ waitStatus == Node.SIGNAL æ¥å†³å®šï¼Œè€Œä¸æ˜¯æœ¬èŠ‚ç‚¹çš„ waitStatus å†³å®š



##### 3. è§£é”æºç 

```java
// Sync ç»§æ‰¿è‡ª AQS
static final class NonfairSync extends Sync {
    // è§£é”å®ç°
    public void unlock() {
        sync.release(1);
    }

    // AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    public final boolean release(int arg) {
        // å°è¯•é‡Šæ”¾é”, è¿›å…¥ ãˆ 
        if (tryRelease(arg)) {
            // é˜Ÿåˆ—å¤´èŠ‚ç‚¹ unpark
            Node h = head; 
            if (
                // é˜Ÿåˆ—ä¸ä¸º null
                h != null &&
                // waitStatus == Node.SIGNAL æ‰éœ€è¦ unpark
                h.waitStatus != 0
            ) {
                // unpark AQS ä¸­ç­‰å¾…çš„çº¿ç¨‹, è¿›å…¥ ãˆ¡
                unparkSuccessor(h);
            }
            return true;
        }
        return false;
    }

    // ãˆ  Sync ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    protected final boolean tryRelease(int releases) {
        // state--
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        // æ”¯æŒé”é‡å…¥, åªæœ‰ state å‡ä¸º 0, æ‰é‡Šæ”¾æˆåŠŸ
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }

    // ãˆ¡ AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    private void unparkSuccessor(Node node) {
        // å¦‚æœçŠ¶æ€ä¸º Node.SIGNAL å°è¯•é‡ç½®çŠ¶æ€ä¸º 0
        // ä¸æˆåŠŸä¹Ÿå¯ä»¥
        int ws = node.waitStatus;
        if (ws < 0) {
            compareAndSetWaitStatus(node, ws, 0);
        }
        // æ‰¾åˆ°éœ€è¦ unpark çš„èŠ‚ç‚¹, ä½†æœ¬èŠ‚ç‚¹ä» AQS é˜Ÿåˆ—ä¸­è„±ç¦», æ˜¯ç”±å”¤é†’èŠ‚ç‚¹å®Œæˆçš„
        Node s = node.next;
        // ä¸è€ƒè™‘å·²å–æ¶ˆçš„èŠ‚ç‚¹, ä» AQS é˜Ÿåˆ—ä»åè‡³å‰æ‰¾åˆ°é˜Ÿåˆ—æœ€å‰é¢éœ€è¦ unpark çš„èŠ‚ç‚¹
        if (s == null || s.waitStatus > 0) {
            s = null;
            for (Node t = tail; t != null && t != node; t = t.prev)
                if (t.waitStatus <= 0)
                    s = t;
        }
        if (s != null)
            LockSupport.unpark(s.thread);
    }
}
```





#### 2. å¯é‡å…¥åŸç†

```java
static final class NonfairSync extends Sync {
    // ...

    // Sync ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        // å¦‚æœå·²ç»è·å¾—äº†é”, çº¿ç¨‹è¿˜æ˜¯å½“å‰çº¿ç¨‹, è¡¨ç¤ºå‘ç”Ÿäº†é”é‡å…¥
        else if (current == getExclusiveOwnerThread()) {
            // state++
            int nextc = c + acquires;
            if (nextc < 0) // overflow
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }

    // Sync ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    protected final boolean tryRelease(int releases) {
        // state-- 
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        // æ”¯æŒé”é‡å…¥, åªæœ‰ state å‡ä¸º 0, æ‰é‡Šæ”¾æˆåŠŸ
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }
}
```





#### 3. å¯æ‰“æ–­åŸç†

##### 1. ä¸å¯æ‰“æ–­æ¨¡å¼

åœ¨æ­¤æ¨¡å¼ä¸‹ï¼Œå³ä½¿å®ƒè¢«æ‰“æ–­ï¼Œä»ä¼šé©»ç•™åœ¨ AQS é˜Ÿåˆ—ä¸­ï¼Œä¸€ç›´è¦ç­‰åˆ°è·å¾—é”åæ–¹èƒ½å¾—çŸ¥è‡ªå·±è¢«æ‰“æ–­äº†

```java
// Sync ç»§æ‰¿è‡ª AQS
static final class NonfairSync extends Sync {
    // ...

    private final boolean parkAndCheckInterrupt() {
        // å¦‚æœæ‰“æ–­æ ‡è®°å·²ç»æ˜¯ true, åˆ™ park ä¼šå¤±æ•ˆ
        LockSupport.park(this);
        // interrupted ä¼šæ¸…é™¤æ‰“æ–­æ ‡è®°
        return Thread.interrupted();
    }

    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null;
                    failed = false;
                    // è¿˜æ˜¯éœ€è¦è·å¾—é”å, æ‰èƒ½è¿”å›æ‰“æ–­çŠ¶æ€
                    return interrupted;
                }
                if (
                    shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt()
                ) {
                    // å¦‚æœæ˜¯å› ä¸º interrupt è¢«å”¤é†’, è¿”å›æ‰“æ–­çŠ¶æ€ä¸º true
                    interrupted = true;
                }
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

    public final void acquire(int arg) {
        if (
            !tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)
        ) {
            // å¦‚æœæ‰“æ–­çŠ¶æ€ä¸º true
            selfInterrupt();
        }
    }

    static void selfInterrupt() {
        // é‡æ–°äº§ç”Ÿä¸€æ¬¡ä¸­æ–­
        Thread.currentThread().interrupt();
    }
}

```



##### 2. å¯æ‰“æ–­æ¨¡å¼

```java
static final class NonfairSync extends Sync {
    public final void acquireInterruptibly(int arg) throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        // å¦‚æœæ²¡æœ‰è·å¾—åˆ°é”, è¿›å…¥ ãˆ 
        if (!tryAcquire(arg))
            doAcquireInterruptibly(arg);
    }

    // ãˆ  å¯æ‰“æ–­çš„è·å–é”æµç¨‹
    private void doAcquireInterruptibly(int arg) throws InterruptedException {
        final Node node = addWaiter(Node.EXCLUSIVE);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt()) {
                    // åœ¨ park è¿‡ç¨‹ä¸­å¦‚æœè¢« interrupt ä¼šè¿›å…¥æ­¤
                    // è¿™æ—¶å€™æŠ›å‡ºå¼‚å¸¸, è€Œä¸ä¼šå†æ¬¡è¿›å…¥ for (;;)
                    throw new InterruptedException();
                }
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
}
```





#### 4. å…¬å¹³é”å®ç°åŸç†

```java
static final class FairSync extends Sync {
    private static final long serialVersionUID = -3000897897090466540L;
    final void lock() {
        acquire(1);
    }

    // AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    public final void acquire(int arg) {
        if (
            !tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)
        ) {
            selfInterrupt();
        }
    }
    // ä¸éå…¬å¹³é”ä¸»è¦åŒºåˆ«åœ¨äº tryAcquire æ–¹æ³•çš„å®ç°
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            // å…ˆæ£€æŸ¥ AQS é˜Ÿåˆ—ä¸­æ˜¯å¦æœ‰å‰é©±èŠ‚ç‚¹, æ²¡æœ‰æ‰å»ç«äº‰
            if (!hasQueuedPredecessors() &&
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc < 0)
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }

    // ãˆ  AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    public final boolean hasQueuedPredecessors() {
        Node t = tail;
        Node h = head;
        Node s;
        // h != t æ—¶è¡¨ç¤ºé˜Ÿåˆ—ä¸­æœ‰ Node
        return h != t &&
            (
            // (s = h.next) == null è¡¨ç¤ºé˜Ÿåˆ—ä¸­è¿˜æœ‰æ²¡æœ‰è€äºŒ
            (s = h.next) == null ||
            // æˆ–è€…é˜Ÿåˆ—ä¸­è€äºŒçº¿ç¨‹ä¸æ˜¯æ­¤çº¿ç¨‹
            s.thread != Thread.currentThread()
        );
    }
}

```





#### 5.  æ¡ä»¶å˜é‡å®ç°åŸç†

æ¯ä¸ªæ¡ä»¶å˜é‡å…¶å®å°±å¯¹åº”ç€ä¸€ä¸ªç­‰å¾…é˜Ÿåˆ—ï¼Œå…¶å®ç°ç±»æ˜¯ ConditionObject

##### 1. await æµç¨‹

å¼€å§‹ Thread-0 æŒæœ‰é”ï¼Œè°ƒç”¨ awaitï¼Œè¿›å…¥ ConditionObject çš„ addConditionWaiter æµç¨‹

åˆ›å»ºæ–°çš„ Node çŠ¶æ€ä¸º -2ï¼ˆNode.CONDITIONï¼‰ï¼Œå…³è” Thread-0ï¼ŒåŠ å…¥ç­‰å¾…é˜Ÿåˆ—å°¾éƒ¨

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192117740.png)

æ¥ä¸‹æ¥è¿›å…¥ AQS çš„ fullyRelease æµç¨‹ï¼Œé‡Šæ”¾åŒæ­¥å™¨ä¸Šçš„é”

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192117233.png)

unpark AQS é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç«äº‰é”ï¼Œå‡è®¾æ²¡æœ‰å…¶ä»–ç«äº‰çº¿ç¨‹ï¼Œé‚£ä¹ˆ Thread-1 ç«äº‰æˆåŠŸ

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192117556.png)

park é˜»å¡ Thread-0

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192117613.png)



##### 2. signal æµç¨‹

å‡è®¾ Thread-1 è¦æ¥å”¤é†’ Thread-0

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192117895.png)

è¿›å…¥ ConditionObject çš„ doSignal æµç¨‹ï¼Œå–å¾—ç­‰å¾…é˜Ÿåˆ—ä¸­ç¬¬ä¸€ä¸ª Nodeï¼Œå³ Thread-0 æ‰€åœ¨ Node

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192118465.png)

æ‰§è¡Œ transferForSignal æµç¨‹ï¼Œå°†è¯¥ Node åŠ å…¥ AQS é˜Ÿåˆ—å°¾éƒ¨ï¼Œå°† Thread-0 çš„ waitStatus æ”¹ä¸º 0ï¼ŒThread-3 çš„ waitStatus æ”¹ä¸º -1

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192118818.png)

Thread-1 é‡Šæ”¾é”ï¼Œè¿›å…¥ unlock æµç¨‹ï¼Œç•¥



##### 3. æºç 

```java
public class ConditionObject implements Condition, java.io.Serializable {
    private static final long serialVersionUID = 1173984872572414699L;

    // ç¬¬ä¸€ä¸ªç­‰å¾…èŠ‚ç‚¹
    private transient Node firstWaiter;

    // æœ€åä¸€ä¸ªç­‰å¾…èŠ‚ç‚¹
    private transient Node lastWaiter;
    public ConditionObject() { }
    
    // ãˆ  æ·»åŠ ä¸€ä¸ª Node è‡³ç­‰å¾…é˜Ÿåˆ—
    private Node addConditionWaiter() {
        Node t = lastWaiter;
        // æ‰€æœ‰å·²å–æ¶ˆçš„ Node ä»é˜Ÿåˆ—é“¾è¡¨åˆ é™¤, è§ ãˆ¡
        if (t != null && t.waitStatus != Node.CONDITION) {
            unlinkCancelledWaiters();
            t = lastWaiter;
        }
        // åˆ›å»ºä¸€ä¸ªå…³è”å½“å‰çº¿ç¨‹çš„æ–° Node, æ·»åŠ è‡³é˜Ÿåˆ—å°¾éƒ¨
        Node node = new Node(Thread.currentThread(), Node.CONDITION);
        if (t == null)
            firstWaiter = node;
        else
            t.nextWaiter = node;
        lastWaiter = node;
        return node;
    }
    
    // å”¤é†’ - å°†æ²¡å–æ¶ˆçš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹è½¬ç§»è‡³ AQS é˜Ÿåˆ—
    private void doSignal(Node first) {
        do {
            // å·²ç»æ˜¯å°¾èŠ‚ç‚¹äº†
            if ( (firstWaiter = first.nextWaiter) == null) {
                lastWaiter = null;
            }
            first.nextWaiter = null;
        } while (
            // å°†ç­‰å¾…é˜Ÿåˆ—ä¸­çš„ Node è½¬ç§»è‡³ AQS é˜Ÿåˆ—, ä¸æˆåŠŸä¸”è¿˜æœ‰èŠ‚ç‚¹åˆ™ç»§ç»­å¾ªç¯ ãˆ¢
            !transferForSignal(first) &&
            // é˜Ÿåˆ—è¿˜æœ‰èŠ‚ç‚¹
            (first = firstWaiter) != null
        );
    }

    // å¤–éƒ¨ç±»æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    // ãˆ¢ å¦‚æœèŠ‚ç‚¹çŠ¶æ€æ˜¯å–æ¶ˆ, è¿”å› false è¡¨ç¤ºè½¬ç§»å¤±è´¥, å¦åˆ™è½¬ç§»æˆåŠŸ
    final boolean transferForSignal(Node node) {
        // å¦‚æœçŠ¶æ€å·²ç»ä¸æ˜¯ Node.CONDITION, è¯´æ˜è¢«å–æ¶ˆäº†
        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
            return false;
        // åŠ å…¥ AQS é˜Ÿåˆ—å°¾éƒ¨
        Node p = enq(node);
        int ws = p.waitStatus;
        if (
            // ä¸Šä¸€ä¸ªèŠ‚ç‚¹è¢«å–æ¶ˆ
            ws > 0 ||
            // ä¸Šä¸€ä¸ªèŠ‚ç‚¹ä¸èƒ½è®¾ç½®çŠ¶æ€ä¸º Node.SIGNAL
            !compareAndSetWaitStatus(p, ws, Node.SIGNAL) 
        ) {
            // unpark å–æ¶ˆé˜»å¡, è®©çº¿ç¨‹é‡æ–°åŒæ­¥çŠ¶æ€
            LockSupport.unpark(node.thread);
        }
        return true;
    }
    
    // å…¨éƒ¨å”¤é†’ - ç­‰å¾…é˜Ÿåˆ—çš„æ‰€æœ‰èŠ‚ç‚¹è½¬ç§»è‡³ AQS é˜Ÿåˆ—
    private void doSignalAll(Node first) {
        lastWaiter = firstWaiter = null;
        do {
            Node next = first.nextWaiter;
            first.nextWaiter = null;
            transferForSignal(first);
            first = next;
        } while (first != null);
    }

    // ãˆ¡
    private void unlinkCancelledWaiters() {
        // ...
    }
    
    // å”¤é†’ - å¿…é¡»æŒæœ‰é”æ‰èƒ½å”¤é†’, å› æ­¤ doSignal å†…æ— éœ€è€ƒè™‘åŠ é”
    public final void signal() {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        Node first = firstWaiter;
        if (first != null)
            doSignal(first);
    }
    
    // å…¨éƒ¨å”¤é†’ - å¿…é¡»æŒæœ‰é”æ‰èƒ½å”¤é†’, å› æ­¤ doSignalAll å†…æ— éœ€è€ƒè™‘åŠ é”
    public final void signalAll() {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        Node first = firstWaiter;
        if (first != null)
            doSignalAll(first);
    }
    
    // ä¸å¯æ‰“æ–­ç­‰å¾… - ç›´åˆ°è¢«å”¤é†’
    public final void awaitUninterruptibly() {
        // æ·»åŠ ä¸€ä¸ª Node è‡³ç­‰å¾…é˜Ÿåˆ—, è§ ãˆ 
        Node node = addConditionWaiter();
        // é‡Šæ”¾èŠ‚ç‚¹æŒæœ‰çš„é”, è§ ãˆ£
        int savedState = fullyRelease(node);
        boolean interrupted = false;
        // å¦‚æœè¯¥èŠ‚ç‚¹è¿˜æ²¡æœ‰è½¬ç§»è‡³ AQS é˜Ÿåˆ—, é˜»å¡
        while (!isOnSyncQueue(node)) {
            // park é˜»å¡
            LockSupport.park(this);
            // å¦‚æœè¢«æ‰“æ–­, ä»…è®¾ç½®æ‰“æ–­çŠ¶æ€
            if (Thread.interrupted())
                interrupted = true;
        }
        // å”¤é†’å, å°è¯•ç«äº‰é”, å¦‚æœå¤±è´¥è¿›å…¥ AQS é˜Ÿåˆ—
        if (acquireQueued(node, savedState) || interrupted)
            selfInterrupt();
    }
    
    // å¤–éƒ¨ç±»æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    // ãˆ£ å› ä¸ºæŸçº¿ç¨‹å¯èƒ½é‡å…¥ï¼Œéœ€è¦å°† state å…¨éƒ¨é‡Šæ”¾
    final int fullyRelease(Node node) {
        boolean failed = true;
        try {
            int savedState = getState();
            if (release(savedState)) {
                failed = false;
                return savedState;
            } else {
                throw new IllegalMonitorStateException();
            }
        } finally {
            if (failed)
                node.waitStatus = Node.CANCELLED;
        }
    }
    
    // æ‰“æ–­æ¨¡å¼ - åœ¨é€€å‡ºç­‰å¾…æ—¶é‡æ–°è®¾ç½®æ‰“æ–­çŠ¶æ€
    private static final int REINTERRUPT = 1;
    
    // æ‰“æ–­æ¨¡å¼ - åœ¨é€€å‡ºç­‰å¾…æ—¶æŠ›å‡ºå¼‚å¸¸
    private static final int THROW_IE = -1;
    
    // åˆ¤æ–­æ‰“æ–­æ¨¡å¼
    private int checkInterruptWhileWaiting(Node node) {
        return Thread.interrupted() ?
            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
        0;
    }
    
    // ãˆ¤ åº”ç”¨æ‰“æ–­æ¨¡å¼
    private void reportInterruptAfterWait(int interruptMode)
        throws InterruptedException {
        if (interruptMode == THROW_IE)
            throw new InterruptedException();
        else if (interruptMode == REINTERRUPT)
            selfInterrupt();
    }
    
    // ç­‰å¾… - ç›´åˆ°è¢«å”¤é†’æˆ–æ‰“æ–­
    public final void await() throws InterruptedException {
        if (Thread.interrupted()) {
            throw new InterruptedException();
        }
        // æ·»åŠ ä¸€ä¸ª Node è‡³ç­‰å¾…é˜Ÿåˆ—, è§ ãˆ 
        Node node = addConditionWaiter();
        // é‡Šæ”¾èŠ‚ç‚¹æŒæœ‰çš„é”
        int savedState = fullyRelease(node);
        int interruptMode = 0;
        // å¦‚æœè¯¥èŠ‚ç‚¹è¿˜æ²¡æœ‰è½¬ç§»è‡³ AQS é˜Ÿåˆ—, é˜»å¡
        while (!isOnSyncQueue(node)) {
            // park é˜»å¡
            LockSupport.park(this);
            // å¦‚æœè¢«æ‰“æ–­, é€€å‡ºç­‰å¾…é˜Ÿåˆ—
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
        }
        // é€€å‡ºç­‰å¾…é˜Ÿåˆ—å, è¿˜éœ€è¦è·å¾— AQS é˜Ÿåˆ—çš„é”
        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        // æ‰€æœ‰å·²å–æ¶ˆçš„ Node ä»é˜Ÿåˆ—é“¾è¡¨åˆ é™¤, è§ ãˆ¡
        if (node.nextWaiter != null) 
            unlinkCancelledWaiters();
        // åº”ç”¨æ‰“æ–­æ¨¡å¼, è§ ãˆ¤
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
    }
    
    // ç­‰å¾… - ç›´åˆ°è¢«å”¤é†’æˆ–æ‰“æ–­æˆ–è¶…æ—¶
    public final long awaitNanos(long nanosTimeout) throws InterruptedException {
        if (Thread.interrupted()) {
            throw new InterruptedException();
        }
        // æ·»åŠ ä¸€ä¸ª Node è‡³ç­‰å¾…é˜Ÿåˆ—, è§ ãˆ 
        Node node = addConditionWaiter();
        // é‡Šæ”¾èŠ‚ç‚¹æŒæœ‰çš„é”
        int savedState = fullyRelease(node);
        // è·å¾—æœ€åæœŸé™
        final long deadline = System.nanoTime() + nanosTimeout;
        int interruptMode = 0;
        // å¦‚æœè¯¥èŠ‚ç‚¹è¿˜æ²¡æœ‰è½¬ç§»è‡³ AQS é˜Ÿåˆ—, é˜»å¡
        while (!isOnSyncQueue(node)) {
            // å·²è¶…æ—¶, é€€å‡ºç­‰å¾…é˜Ÿåˆ—
            if (nanosTimeout <= 0L) {
                transferAfterCancelledWait(node);
                break;
            }
            // park é˜»å¡ä¸€å®šæ—¶é—´, spinForTimeoutThreshold ä¸º 1000 ns
            if (nanosTimeout >= spinForTimeoutThreshold)
                LockSupport.parkNanos(this, nanosTimeout);
            // å¦‚æœè¢«æ‰“æ–­, é€€å‡ºç­‰å¾…é˜Ÿåˆ—
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
            nanosTimeout = deadline - System.nanoTime();
        }
        // é€€å‡ºç­‰å¾…é˜Ÿåˆ—å, è¿˜éœ€è¦è·å¾— AQS é˜Ÿåˆ—çš„é”
        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        // æ‰€æœ‰å·²å–æ¶ˆçš„ Node ä»é˜Ÿåˆ—é“¾è¡¨åˆ é™¤, è§ ãˆ¡
        if (node.nextWaiter != null)
            unlinkCancelledWaiters();
        // åº”ç”¨æ‰“æ–­æ¨¡å¼, è§ ãˆ¤
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
        return deadline - System.nanoTime();
    }
    
    // ç­‰å¾… - ç›´åˆ°è¢«å”¤é†’æˆ–æ‰“æ–­æˆ–è¶…æ—¶, é€»è¾‘ç±»ä¼¼äº awaitNanos
    public final boolean awaitUntil(Date deadline) throws InterruptedException {
        // ...
    }
    
    // ç­‰å¾… - ç›´åˆ°è¢«å”¤é†’æˆ–æ‰“æ–­æˆ–è¶…æ—¶, é€»è¾‘ç±»ä¼¼äº awaitNanos
    public final boolean await(long time, TimeUnit unit) throws InterruptedException {
        // ...
    }
    // å·¥å…·æ–¹æ³• çœç•¥ ...
}

```







### 3. è¯»å†™é”

#### 1. ReentrantReadWriteLock

å½“è¯»æ“ä½œè¿œè¿œé«˜äºå†™æ“ä½œæ—¶ï¼Œè¿™æ—¶å€™ä½¿ç”¨ `è¯»å†™é”` è®© `è¯»-è¯»` å¯ä»¥å¹¶å‘ï¼Œæé«˜æ€§èƒ½ã€‚ ç±»ä¼¼äºæ•°æ®åº“ä¸­çš„ `select ... from ... lock in share mode`

æä¾›ä¸€ä¸ª `æ•°æ®å®¹å™¨ç±»` å†…éƒ¨åˆ†åˆ«ä½¿ç”¨è¯»é”ä¿æŠ¤æ•°æ®çš„ `read()` æ–¹æ³•ï¼Œå†™é”ä¿æŠ¤æ•°æ®çš„ `write()` æ–¹æ³•

```java
class DataContainer {
    private Object data;
    private ReentrantReadWriteLock rw = new ReentrantReadWriteLock();
    private ReentrantReadWriteLock.ReadLock r = rw.readLock();
    private ReentrantReadWriteLock.WriteLock w = rw.writeLock();
    
    public Object read() {
        log.debug("è·å–è¯»é”...");
        r.lock();
        try {
            log.debug("è¯»å–");
            sleep(1);
            return data;
        } finally {
            log.debug("é‡Šæ”¾è¯»é”...");
            r.unlock();
        }
    }
    
    public void write() {
        log.debug("è·å–å†™é”...");
        w.lock();
        try {
            log.debug("å†™å…¥");
            sleep(1);
        } finally {
            log.debug("é‡Šæ”¾å†™é”...");
            w.unlock();
        }
    }
}
```

æµ‹è¯• `è¯»é”-è¯»é”` å¯ä»¥å¹¶å‘

```java
DataContainer dataContainer = new DataContainer();
new Thread(() -> {
    dataContainer.read();
}, "t1").start();
new Thread(() -> {
    dataContainer.read();
}, "t2").start();
```

```shell
# ç»“æœ
13:12:41.852 c.DataContainer [t1] - è·å–è¯»é”...
13:12:41.849 c.DataContainer [t2] - è·å–è¯»é”...
13:12:41.856 c.DataContainer [t1] - è¯»å–
13:12:41.856 c.DataContainer [t2] - è¯»å–
13:12:42.863 c.DataContainer [t1] - é‡Šæ”¾è¯»é”...
13:12:42.863 c.DataContainer [t2] - é‡Šæ”¾è¯»é”...
```

æµ‹è¯• `è¯»é”-å†™é”` ç›¸äº’é˜»å¡

```java
DataContainer dataContainer = new DataContainer();
new Thread(() -> {
    dataContainer.read();
}, "t1").start();
Thread.sleep(100);
new Thread(() -> {
    dataContainer.write();
}, "t2").start();
```

```shell
# ç»“æœ
13:15:04.422 c.DataContainer [t1] - è·å–è¯»é”...
13:15:04.437 c.DataContainer [t1] - è¯»å–
13:15:04.534 c.DataContainer [t2] - è·å–å†™é”...
13:15:05.453 c.DataContainer [t1] - é‡Šæ”¾è¯»é”...
13:15:05.453 c.DataContainer [t2] - å†™å…¥
13:15:06.465 c.DataContainer [t2] - é‡Šæ”¾å†™é”...
```



**æ³¨æ„äº‹é¡¹**

- è¯»é”ä¸æ”¯æŒæ¡ä»¶å˜é‡
- é‡å…¥æ—¶å‡çº§ä¸æ”¯æŒï¼šå³æŒæœ‰è¯»é”çš„æƒ…å†µä¸‹å»è·å–å†™é”ï¼Œä¼šå¯¼è‡´è·å–å†™é”æ°¸ä¹…ç­‰å¾…

```java
r.lock();
try {
    // ...
    w.lock();
    try {
        // ...
    } finally{
        w.unlock();
    }
} finally{
    r.unlock();
}
```

- é‡å…¥æ—¶é™çº§æ”¯æŒï¼šå³æŒæœ‰å†™é”çš„æƒ…å†µä¸‹å»è·å–è¯»é”

```java
class CachedData {
    Object data;
    // æ˜¯å¦æœ‰æ•ˆï¼Œå¦‚æœå¤±æ•ˆï¼Œéœ€è¦é‡æ–°è®¡ç®— data
    volatile boolean cacheValid;
    final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    
    void processCachedData() {
        rwl.readLock().lock();
        if (!cacheValid) {
            // è·å–å†™é”å‰å¿…é¡»é‡Šæ”¾è¯»é”
            rwl.readLock().unlock();
            rwl.writeLock().lock();
            try {
                // åˆ¤æ–­æ˜¯å¦æœ‰å…¶å®ƒçº¿ç¨‹å·²ç»è·å–äº†å†™é”ã€æ›´æ–°äº†ç¼“å­˜, é¿å…é‡å¤æ›´æ–°
                if (!cacheValid) {
                    data = ...
                        cacheValid = true;
                }
                // é™çº§ä¸ºè¯»é”, é‡Šæ”¾å†™é”, è¿™æ ·èƒ½å¤Ÿè®©å…¶å®ƒçº¿ç¨‹è¯»å–ç¼“å­˜
                rwl.readLock().lock();
            } finally {
                rwl.writeLock().unlock();
            }
        }
        // è‡ªå·±ç”¨å®Œæ•°æ®, é‡Šæ”¾è¯»é” 
        try {
            use(data);
        } finally {
            rwl.readLock().unlock();
        }
    }
}
```





#### 2. åº”ç”¨ä¹‹ç¼“å­˜

##### 1. ç¼“å­˜æ›´æ–°ç­–ç•¥

æ›´æ–°æ—¶ï¼Œæ˜¯å…ˆæ¸…ç¼“å­˜è¿˜æ˜¯å…ˆæ›´æ–°æ•°æ®åº“

å…ˆæ¸…ç¼“å­˜

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192118447.png)

å…ˆæ›´æ–°æ•°æ®åº“

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192119161.png)

è¡¥å……ä¸€ç§æƒ…å†µï¼Œå‡è®¾æŸ¥è¯¢çº¿ç¨‹ A æŸ¥è¯¢æ•°æ®æ—¶æ°å¥½ç¼“å­˜æ•°æ®ç”±äºæ—¶é—´åˆ°æœŸå¤±æ•ˆï¼Œæˆ–æ˜¯ç¬¬ä¸€æ¬¡æŸ¥è¯¢

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192119045.png)

è¿™ç§æƒ…å†µçš„å‡ºç°å‡ ç‡éå¸¸å°ï¼Œè§ facebook è®ºæ–‡



##### 2. è¯»å†™é”å®ç°ä¸€è‡´æ€§ç¼“å­˜

```java
public class GenericDao {
    static String URL = "jdbc:mysql://localhost:3306/test";
    static String USERNAME = "root";
    static String PASSWORD = "root";

    public <T> List<T> queryList(Class<T> beanClass, String sql, Object... args) {
        System.out.println("sql: [" + sql + "] params:" + Arrays.toString(args));
        BeanRowMapper<T> mapper = new BeanRowMapper<>(beanClass);
        return queryList(sql, mapper, args);
    }

    public <T> T queryOne(Class<T> beanClass, String sql, Object... args) {
        System.out.println("sql: [" + sql + "] params:" + Arrays.toString(args));
        BeanRowMapper<T> mapper = new BeanRowMapper<>(beanClass);
        return queryOne(sql, mapper, args);
    }

    private <T> List<T> queryList(String sql, RowMapper<T> mapper, Object... args) {
        try (Connection conn = DriverManager.getConnection(URL, USERNAME, PASSWORD)) {
            try (PreparedStatement psmt = conn.prepareStatement(sql)) {
                if (args != null) {
                    for (int i = 0; i < args.length; i++) {
                        psmt.setObject(i + 1, args[i]);
                    }
                }
                List<T> list = new ArrayList<>();
                try (ResultSet rs = psmt.executeQuery()) {
                    while (rs.next()) {
                        T obj = mapper.map(rs);
                        list.add(obj);
                    }
                }
                return list;
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    private <T> T queryOne(String sql, RowMapper<T> mapper, Object... args) {
        List<T> list = queryList(sql, mapper, args);
        return list.size() == 0 ? null : list.get(0);
    }

    public int update(String sql, Object... args) {
        System.out.println("sql: [" + sql + "] params:" + Arrays.toString(args));
        try (Connection conn = DriverManager.getConnection(URL, USERNAME, PASSWORD)) {
            try (PreparedStatement psmt = conn.prepareStatement(sql)) {
                if (args != null) {
                    for (int i = 0; i < args.length; i++) {
                        psmt.setObject(i + 1, args[i]);
                    }
                }
                return psmt.executeUpdate();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    interface RowMapper<T> {
        T map(ResultSet rs);
    }

    static class BeanRowMapper<T> implements RowMapper<T> {

        private Class<T> beanClass;
        private Map<String, PropertyDescriptor> propertyMap = new HashMap<>();

        public BeanRowMapper(Class<T> beanClass) {
            this.beanClass = beanClass;
            try {
                BeanInfo beanInfo = Introspector.getBeanInfo(beanClass);
                PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();
                for (PropertyDescriptor pd : propertyDescriptors) {
                    propertyMap.put(pd.getName().toLowerCase(), pd);
                }
            } catch (IntrospectionException e) {
                throw new RuntimeException(e);
            }
        }

        @Override
        public T map(ResultSet rs) {
            try {
                ResultSetMetaData metaData = rs.getMetaData();
                int columnCount = metaData.getColumnCount();
                T t = beanClass.newInstance();
                for (int i = 1; i <= columnCount; i++) {
                    String columnLabel = metaData.getColumnLabel(i);
                    PropertyDescriptor pd = propertyMap.get(columnLabel.toLowerCase());
                    if (pd != null) {
                        pd.getWriteMethod().invoke(t, rs.getObject(i));
                    }
                }
                return t;
            } catch (SQLException | InstantiationException | IllegalAccessException | InvocationTargetException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
```

```java
class GenericDaoCached extends GenericDao {
    private GenericDao dao = new GenericDao();
    private Map<SqlPair, Object> map = new HashMap<>();
    private ReentrantReadWriteLock rw = new ReentrantReadWriteLock();

    @Override
    public <T> List<T> queryList(Class<T> beanClass, String sql, Object... args) {
        return dao.queryList(beanClass, sql, args);
    }

    @Override
    public <T> T queryOne(Class<T> beanClass, String sql, Object... args) {
        // å…ˆä»ç¼“å­˜ä¸­æ‰¾ï¼Œæ‰¾åˆ°ç›´æ¥è¿”å›
        SqlPair key = new SqlPair(sql, args);;
        rw.readLock().lock();
        try {
            T value = (T) map.get(key);
            if(value != null) {
                return value;
            }
        } finally {
            rw.readLock().unlock();
        }
        rw.writeLock().lock();
        try {
            // å¤šä¸ªçº¿ç¨‹
            T value = (T) map.get(key);
            if(value == null) {
                // ç¼“å­˜ä¸­æ²¡æœ‰ï¼ŒæŸ¥è¯¢æ•°æ®åº“
                value = dao.queryOne(beanClass, sql, args);
                map.put(key, value);
            }
            return value;
        } finally {
            rw.writeLock().unlock();
        }
    }

    @Override
    public int update(String sql, Object... args) {
        rw.writeLock().lock();
        try {
            // å…ˆæ›´æ–°åº“
            int update = dao.update(sql, args);
            // æ¸…ç©ºç¼“å­˜
            map.clear();
            return update;
        } finally {
            rw.writeLock().unlock();
        }
    }

    class SqlPair {
        private String sql;
        private Object[] args;

        public SqlPair(String sql, Object[] args) {
            this.sql = sql;
            this.args = args;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            SqlPair sqlPair = (SqlPair) o;
            return Objects.equals(sql, sqlPair.sql) &&
                    Arrays.equals(args, sqlPair.args);
        }

        @Override
        public int hashCode() {
            int result = Objects.hash(sql);
            result = 31 * result + Arrays.hashCode(args);
            return result;
        }
    }
}
```

> **æ³¨æ„**
>
> - ä»¥ä¸Šå®ç°ä½“ç°çš„æ˜¯è¯»å†™é”çš„åº”ç”¨ï¼Œä¿è¯ç¼“å­˜å’Œæ•°æ®åº“çš„ä¸€è‡´æ€§ï¼Œä½†æœ‰ä¸‹é¢çš„é—®é¢˜æ²¡æœ‰è€ƒè™‘
>   - é€‚åˆè¯»å¤šå†™å°‘ï¼Œå¦‚æœå†™æ“ä½œæ¯”è¾ƒé¢‘ç¹ï¼Œä»¥ä¸Šå®ç°æ€§èƒ½ä½
>   - æ²¡æœ‰è€ƒè™‘ç¼“å­˜å®¹é‡
>   - æ²¡æœ‰è€ƒè™‘ç¼“å­˜è¿‡æœŸ
>   - åªé€‚åˆå•æœº 
>   - å¹¶å‘æ€§è¿˜æ˜¯ä½ï¼Œç›®å‰åªä¼šç”¨ä¸€æŠŠé”
>   - æ›´æ–°æ–¹æ³•å¤ªè¿‡ç®€å•ç²—æš´ï¼Œæ¸…ç©ºäº†æ‰€æœ‰ keyï¼ˆè€ƒè™‘æŒ‰ç±»å‹åˆ†åŒºæˆ–é‡æ–°è®¾è®¡ keyï¼‰
> - ä¹è§‚é”å®ç°ï¼šç”¨ CAS å»æ›´æ–°





#### 3. è¯»å†™é”åŸç†

##### 1. å›¾è§£æµç¨‹

è¯»å†™é”ç”¨çš„æ˜¯åŒä¸€ä¸ª Sycn åŒæ­¥å™¨ï¼Œå› æ­¤ç­‰å¾…é˜Ÿåˆ—ã€state ç­‰ä¹Ÿæ˜¯åŒä¸€ä¸ª

**1. t1 w.lockï¼Œt2 r.lock**

1. t1 æˆåŠŸä¸Šé”ï¼Œæµç¨‹ä¸ ReentrantLock åŠ é”ç›¸æ¯”æ²¡æœ‰ç‰¹æ®Šä¹‹å¤„ï¼Œä¸åŒæ˜¯å†™é”çŠ¶æ€å äº† state çš„ä½ 16 ä½ï¼Œè€Œè¯»é” ä½¿ç”¨çš„æ˜¯ state çš„é«˜ 16 ä½

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192119420.png)

2. t2 æ‰§è¡Œ r.lockï¼Œè¿™æ—¶è¿›å…¥è¯»é”çš„ sync.acquireShared(1) æµç¨‹ï¼Œé¦–å…ˆä¼šè¿›å…¥ tryAcquireShared æµç¨‹ã€‚å¦‚æœæœ‰å†™ é”å æ®ï¼Œé‚£ä¹ˆ tryAcquireShared è¿”å› -1 è¡¨ç¤ºå¤±è´¥

   > tryAcquireShared è¿”å›å€¼è¡¨ç¤º
   >
   > - -1 è¡¨ç¤ºå¤±è´¥
   > - 0 è¡¨ç¤ºæˆåŠŸï¼Œä½†åç»§èŠ‚ç‚¹ä¸ä¼šç»§ç»­å”¤é†’
   > - æ­£æ•°è¡¨ç¤ºæˆåŠŸï¼Œè€Œä¸”æ•°å€¼æ˜¯è¿˜æœ‰å‡ ä¸ªåç»§èŠ‚ç‚¹éœ€è¦å”¤é†’ï¼Œè¯»å†™é”è¿”å› 1

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192119025.png)

3. è¿™æ—¶ä¼šè¿›å…¥ sync.doAcquireShared(1) æµç¨‹ï¼Œé¦–å…ˆä¹Ÿæ˜¯è°ƒç”¨ addWaiter æ·»åŠ èŠ‚ç‚¹ï¼Œä¸åŒä¹‹å¤„åœ¨äºèŠ‚ç‚¹è¢«è®¾ç½®ä¸º Node.SHARED æ¨¡å¼è€Œé Node.EXCLUSIVE æ¨¡å¼ï¼Œæ³¨æ„æ­¤æ—¶ t2 ä»å¤„äºæ´»è·ƒçŠ¶æ€

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192120116.png)

4. t2 ä¼šçœ‹çœ‹è‡ªå·±çš„èŠ‚ç‚¹æ˜¯ä¸æ˜¯è€äºŒï¼Œå¦‚æœæ˜¯ï¼Œè¿˜ä¼šå†æ¬¡è°ƒç”¨ tryAcquireShared(1) æ¥å°è¯•è·å–é”

5. å¦‚æœæ²¡æœ‰æˆåŠŸï¼Œåœ¨ doAcquireShared å†… for (;;) å¾ªç¯ä¸€æ¬¡ï¼ŒæŠŠå‰é©±èŠ‚ç‚¹çš„ waitStatus æ”¹ä¸º -1ï¼Œå† for (;;) å¾ªç¯ä¸€ æ¬¡å°è¯• tryAcquireShared(1) å¦‚æœè¿˜ä¸æˆåŠŸï¼Œé‚£ä¹ˆåœ¨ parkAndCheckInterrupt() å¤„ park

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192120867.png)



**2. t3 r.lockï¼Œt4 w.lock**

è¿™ç§çŠ¶æ€ä¸‹ï¼Œå‡è®¾åˆæœ‰ t3 åŠ è¯»é”å’Œ t4 åŠ å†™é”ï¼Œè¿™æœŸé—´ t1 ä»ç„¶æŒæœ‰é”ï¼Œå°±å˜æˆäº†ä¸‹é¢çš„æ ·å­

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192120949.png)



**3. t1 w.unlock**

è¿™æ—¶ä¼šèµ°åˆ°å†™é”çš„ sync.release(1) æµç¨‹ï¼Œè°ƒç”¨ sync.tryRelease(1) æˆåŠŸï¼Œå˜æˆä¸‹é¢çš„æ ·å­

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192120313.png)

æ¥ä¸‹æ¥æ‰§è¡Œå”¤é†’æµç¨‹ sync.unparkSuccessorï¼Œå³è®©è€äºŒæ¢å¤è¿è¡Œï¼Œè¿™æ—¶ t2 åœ¨ doAcquireShared å†… parkAndCheckInterrupt() å¤„æ¢å¤è¿è¡Œ

è¿™å›å†æ¥ä¸€æ¬¡ for (;;) æ‰§è¡Œ tryAcquireShared æˆåŠŸåˆ™è®©è¯»é”è®¡æ•°åŠ ä¸€

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192121503.png)

è¿™æ—¶ t2 å·²ç»æ¢å¤è¿è¡Œï¼Œæ¥ä¸‹æ¥ t2 è°ƒç”¨ setHeadAndPropagate(node, 1)ï¼Œå®ƒåŸæœ¬æ‰€åœ¨èŠ‚ç‚¹è¢«ç½®ä¸ºå¤´èŠ‚ç‚¹

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192121768.png)

äº‹æƒ…è¿˜æ²¡å®Œï¼Œåœ¨ setHeadAndPropagate æ–¹æ³•å†…è¿˜ä¼šæ£€æŸ¥ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¦æ˜¯ sharedï¼Œå¦‚æœæ˜¯åˆ™è°ƒç”¨ doReleaseShared() å°† head çš„çŠ¶æ€ä» -1 æ”¹ä¸º 0 å¹¶å”¤é†’è€äºŒï¼Œè¿™æ—¶ t3 åœ¨ doAcquireShared å†… parkAndCheckInterrupt() å¤„æ¢å¤è¿è¡Œ

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192121689.png)

è¿™å›å†æ¥ä¸€æ¬¡ for (;;) æ‰§è¡Œ tryAcquireShared æˆåŠŸåˆ™è®©è¯»é”è®¡æ•°åŠ ä¸€

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192121313.png)

è¿™æ—¶ t3 å·²ç»æ¢å¤è¿è¡Œï¼Œæ¥ä¸‹æ¥ t3 è°ƒç”¨ setHeadAndPropagate(node, 1)ï¼Œå®ƒåŸæœ¬æ‰€åœ¨èŠ‚ç‚¹è¢«ç½®ä¸ºå¤´èŠ‚ç‚¹

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192122322.png)

ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸æ˜¯ shared äº†ï¼Œå› æ­¤ä¸ä¼šç»§ç»­å”¤é†’ t4 æ‰€åœ¨èŠ‚ç‚¹



**4. t2 r.unlockï¼Œt3 r.unlock**

t2 è¿›å…¥ sync.releaseShared(1) ä¸­ï¼Œè°ƒç”¨ tryReleaseShared(1) è®©è®¡æ•°å‡ä¸€ï¼Œä½†ç”±äºè®¡æ•°è¿˜ä¸ä¸ºé›¶

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192122000.png)

t3 è¿›å…¥ sync.releaseShared(1) ä¸­ï¼Œè°ƒç”¨ tryReleaseShared(1) è®©è®¡æ•°å‡ä¸€ï¼Œè¿™å›è®¡æ•°ä¸ºé›¶äº†ï¼Œè¿›å…¥ doReleaseShared() å°†å¤´èŠ‚ç‚¹ä» -1 æ”¹ä¸º 0 å¹¶å”¤é†’è€äºŒï¼Œå³

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192122937.png)

ä¹‹å t4 åœ¨ acquireQueued ä¸­ parkAndCheckInterrupt å¤„æ¢å¤è¿è¡Œï¼Œå†æ¬¡ for (;;) è¿™æ¬¡è‡ªå·±æ˜¯è€äºŒï¼Œå¹¶ä¸”æ²¡æœ‰å…¶ä»– ç«äº‰ï¼ŒtryAcquire(1) æˆåŠŸï¼Œä¿®æ”¹å¤´ç»“ç‚¹ï¼Œæµç¨‹ç»“æŸ

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192122320.png)



##### 2. æºç åˆ†æ

**1. å†™é”ä¸Šé”æµç¨‹**

```java
static final class NonfairSync extends Sync {
    // ... çœç•¥æ— å…³ä»£ç 

    // å¤–éƒ¨ç±» WriteLock æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    public void lock() {
        sync.acquire(1);
    }

    // AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    public final void acquire(int arg) {
        if (
            // å°è¯•è·å¾—å†™é”å¤±è´¥
            !tryAcquire(arg) &&
            // å°†å½“å‰çº¿ç¨‹å…³è”åˆ°ä¸€ä¸ª Node å¯¹è±¡ä¸Š, æ¨¡å¼ä¸ºç‹¬å æ¨¡å¼
            // è¿›å…¥ AQS é˜Ÿåˆ—é˜»å¡
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)
        ) {
            selfInterrupt();
        }
    }

    // Sync ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    protected final boolean tryAcquire(int acquires) {
        // è·å¾—ä½ 16 ä½, ä»£è¡¨å†™é”çš„ state è®¡æ•°
        Thread current = Thread.currentThread();
        int c = getState();
        int w = exclusiveCount(c);

        if (c != 0) {
            if (
                // c != 0 and w == 0 è¡¨ç¤ºæœ‰è¯»é”, æˆ–è€…
                w == 0 ||
                // å¦‚æœ exclusiveOwnerThread ä¸æ˜¯è‡ªå·±
                current != getExclusiveOwnerThread()
            ) {
                // è·å¾—é”å¤±è´¥
                return false;
            }
            // å†™é”è®¡æ•°è¶…è¿‡ä½ 16 ä½, æŠ¥å¼‚å¸¸
            if (w + exclusiveCount(acquires) > MAX_COUNT)
                throw new Error("Maximum lock count exceeded");
            // å†™é”é‡å…¥, è·å¾—é”æˆåŠŸ
            setState(c + acquires);
            return true;
        } 
        if (
            // åˆ¤æ–­å†™é”æ˜¯å¦è¯¥é˜»å¡, æˆ–è€…
            writerShouldBlock() ||
            // å°è¯•æ›´æ”¹è®¡æ•°å¤±è´¥
            !compareAndSetState(c, c + acquires)
        ) {
            // è·å¾—é”å¤±è´¥
            return false;
        }
        // è·å¾—é”æˆåŠŸ
        setExclusiveOwnerThread(current);
        return true;
    }

    // éå…¬å¹³é” writerShouldBlock æ€»æ˜¯è¿”å› false, æ— éœ€é˜»å¡
    final boolean writerShouldBlock() {
        return false;
    }
}

```



**2. å†™é”é‡Šæ”¾æµç¨‹**

```java
static final class NonfairSync extends Sync {
    // ... çœç•¥æ— å…³ä»£ç 

    // WriteLock æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    public void unlock() {
        sync.release(1);
    }

    // AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    public final boolean release(int arg) {
        // å°è¯•é‡Šæ”¾å†™é”æˆåŠŸ
        if (tryRelease(arg)) {
            // unpark AQS ä¸­ç­‰å¾…çš„çº¿ç¨‹
            Node h = head;
            if (h != null && h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }

    // Sync ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    protected final boolean tryRelease(int releases) {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        int nextc = getState() - releases;
        // å› ä¸ºå¯é‡å…¥çš„åŸå› , å†™é”è®¡æ•°ä¸º 0, æ‰ç®—é‡Šæ”¾æˆåŠŸ
        boolean free = exclusiveCount(nextc) == 0;
        if (free) {
            setExclusiveOwnerThread(null);
        }
        setState(nextc);
        return free;
    }
}
```



**3. è¯»é”ä¸Šé”æµç¨‹**

```java
static final class NonfairSync extends Sync {

    // ReadLock æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    public void lock() {
        sync.acquireShared(1);
    }

    // AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    public final void acquireShared(int arg) {
        // tryAcquireShared è¿”å›è´Ÿæ•°, è¡¨ç¤ºè·å–è¯»é”å¤±è´¥
        if (tryAcquireShared(arg) < 0) {
            doAcquireShared(arg);
        }
    }

    // Sync ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    protected final int tryAcquireShared(int unused) {
        Thread current = Thread.currentThread();
        int c = getState();
        // å¦‚æœæ˜¯å…¶å®ƒçº¿ç¨‹æŒæœ‰å†™é”, è·å–è¯»é”å¤±è´¥
        if ( 
            exclusiveCount(c) != 0 &&
            getExclusiveOwnerThread() != current
        ) {
            return -1;
        }
        int r = sharedCount(c);
        if (
            // è¯»é”ä¸è¯¥é˜»å¡(å¦‚æœè€äºŒæ˜¯å†™é”ï¼Œè¯»é”è¯¥é˜»å¡), å¹¶ä¸”
            !readerShouldBlock() &&
            // å°äºè¯»é”è®¡æ•°, å¹¶ä¸”
            r < MAX_COUNT &&
            // å°è¯•å¢åŠ è®¡æ•°æˆåŠŸ
            compareAndSetState(c, c + SHARED_UNIT)
        ) {
            // ... çœç•¥ä¸é‡è¦çš„ä»£ç 
            return 1;
        }
        return fullTryAcquireShared(current);
    }

    // éå…¬å¹³é” readerShouldBlock çœ‹ AQS é˜Ÿåˆ—ä¸­ç¬¬ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¦æ˜¯å†™é”
    // true åˆ™è¯¥é˜»å¡, false åˆ™ä¸é˜»å¡
    final boolean readerShouldBlock() {
        return apparentlyFirstQueuedIsExclusive();
    }

    // AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    // ä¸ tryAcquireShared åŠŸèƒ½ç±»ä¼¼, ä½†ä¼šä¸æ–­å°è¯• for (;;) è·å–è¯»é”, æ‰§è¡Œè¿‡ç¨‹ä¸­æ— é˜»å¡
    final int fullTryAcquireShared(Thread current) {
        HoldCounter rh = null;
        for (;;) {
            int c = getState();
            if (exclusiveCount(c) != 0) {
                if (getExclusiveOwnerThread() != current)
                    return -1;
            } else if (readerShouldBlock()) {
                // ... çœç•¥ä¸é‡è¦çš„ä»£ç 
            }
            if (sharedCount(c) == MAX_COUNT)
                throw new Error("Maximum lock count exceeded");
            if (compareAndSetState(c, c + SHARED_UNIT)) {
                // ... çœç•¥ä¸é‡è¦çš„ä»£ç 
                return 1;
            }
        }
    }

    // AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    private void doAcquireShared(int arg) {
        // å°†å½“å‰çº¿ç¨‹å…³è”åˆ°ä¸€ä¸ª Node å¯¹è±¡ä¸Š, æ¨¡å¼ä¸ºå…±äº«æ¨¡å¼
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head) {
                    // å†ä¸€æ¬¡å°è¯•è·å–è¯»é”
                    int r = tryAcquireShared(arg);
                    // æˆåŠŸ
                    if (r >= 0) {
                        // ãˆ 
                        // r è¡¨ç¤ºå¯ç”¨èµ„æºæ•°, åœ¨è¿™é‡Œæ€»æ˜¯ 1 å…è®¸ä¼ æ’­
                        //ï¼ˆå”¤é†’ AQS ä¸­ä¸‹ä¸€ä¸ª Share èŠ‚ç‚¹ï¼‰
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        if (interrupted)
                            selfInterrupt();
                        failed = false;
                        return;
                    }
                }
                if (
                    // æ˜¯å¦åœ¨è·å–è¯»é”å¤±è´¥æ—¶é˜»å¡ï¼ˆå‰ä¸€ä¸ªé˜¶æ®µ waitStatus == Node.SIGNALï¼‰
                    shouldParkAfterFailedAcquire(p, node) &&
                    // park å½“å‰çº¿ç¨‹
                    parkAndCheckInterrupt()
                ) {
                    interrupted = true;
                }
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

    // ãˆ  AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    private void setHeadAndPropagate(Node node, int propagate) {
        Node h = head; // Record old head for check below
        // è®¾ç½®è‡ªå·±ä¸º head
        setHead(node);

        // propagate è¡¨ç¤ºæœ‰å…±äº«èµ„æºï¼ˆä¾‹å¦‚å…±äº«è¯»é”æˆ–ä¿¡å·é‡ï¼‰
        // åŸ head waitStatus == Node.SIGNAL æˆ– Node.PROPAGATE
        // ç°åœ¨ head waitStatus == Node.SIGNAL æˆ– Node.PROPAGATE
        if (propagate > 0 || h == null || h.waitStatus < 0 ||
            (h = head) == null || h.waitStatus < 0) {
            Node s = node.next;
            // å¦‚æœæ˜¯æœ€åä¸€ä¸ªèŠ‚ç‚¹æˆ–è€…æ˜¯ç­‰å¾…å…±äº«è¯»é”çš„èŠ‚ç‚¹
            if (s == null || s.isShared()) {
                // è¿›å…¥ ãˆ¡
                doReleaseShared();
            }
        }
    }

    // ãˆ¡ AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    private void doReleaseShared() {
        // å¦‚æœ head.waitStatus == Node.SIGNAL ==> 0 æˆåŠŸ, ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ unpark
        // å¦‚æœ head.waitStatus == 0 ==> Node.PROPAGATE, ä¸ºäº†è§£å†³ bug, è§åé¢åˆ†æ
        for (;;) {
            Node h = head;
            // é˜Ÿåˆ—è¿˜æœ‰èŠ‚ç‚¹
            if (h != null && h != tail) {
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue; // loop to recheck cases
                    // ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ unpark å¦‚æœæˆåŠŸè·å–è¯»é”
                    // å¹¶ä¸”ä¸‹ä¸‹ä¸ªèŠ‚ç‚¹è¿˜æ˜¯ shared, ç»§ç»­ doReleaseShared
                    unparkSuccessor(h);
                }
                else if (ws == 0 &&
                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                    continue; // loop on failed CAS
            }
            if (h == head) // loop if head changed
                break;
        }
    }
}

```



**4. è¯»é”é‡Šæ”¾æµç¨‹**

```java
static final class NonfairSync extends Sync {

    // ReadLock æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    public void unlock() {
        sync.releaseShared(1);
    }

    // AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }

    // Sync ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    protected final boolean tryReleaseShared(int unused) {
        // ... çœç•¥ä¸é‡è¦çš„ä»£ç 
        for (;;) {
            int c = getState();
            int nextc = c - SHARED_UNIT;
            if (compareAndSetState(c, nextc)) {
                // è¯»é”çš„è®¡æ•°ä¸ä¼šå½±å“å…¶å®ƒè·å–è¯»é”çº¿ç¨‹, ä½†ä¼šå½±å“å…¶å®ƒè·å–å†™é”çº¿ç¨‹
                // è®¡æ•°ä¸º 0 æ‰æ˜¯çœŸæ­£é‡Šæ”¾
                return nextc == 0;
            }
        }
    }

    // AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    private void doReleaseShared() {
        // å¦‚æœ head.waitStatus == Node.SIGNAL ==> 0 æˆåŠŸ, ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ unpark
        // å¦‚æœ head.waitStatus == 0 ==> Node.PROPAGATE 
        for (;;) {
            Node h = head;
            if (h != null && h != tail) {
                int ws = h.waitStatus;
                // å¦‚æœæœ‰å…¶å®ƒçº¿ç¨‹ä¹Ÿåœ¨é‡Šæ”¾è¯»é”ï¼Œé‚£ä¹ˆéœ€è¦å°† waitStatus å…ˆæ”¹ä¸º 0
                // é˜²æ­¢ unparkSuccessor è¢«å¤šæ¬¡æ‰§è¡Œ
                if (ws == Node.SIGNAL) {
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue; // loop to recheck cases
                    unparkSuccessor(h);
                }
                // å¦‚æœå·²ç»æ˜¯ 0 äº†ï¼Œæ”¹ä¸º -3ï¼Œç”¨æ¥è§£å†³ä¼ æ’­æ€§ï¼Œè§åæ–‡ä¿¡å·é‡ bug åˆ†æ
                else if (ws == 0 &&
                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                    continue; // loop on failed CAS
            }
            if (h == head) // loop if head changed
                break;
        }
    } 
}
```





#### 4. StampedLock

è¯¥ç±»è‡ª JDK 8 åŠ å…¥ï¼Œæ˜¯ä¸ºäº†è¿›ä¸€æ­¥ä¼˜åŒ–è¯»æ€§èƒ½ï¼Œå®ƒçš„ç‰¹ç‚¹æ˜¯åœ¨ä½¿ç”¨è¯»é”ã€å†™é”æ—¶éƒ½å¿…é¡»é…åˆã€æˆ³ã€‘ä½¿ç”¨

åŠ è§£è¯»é”

```java
long stamp = lock.readLock();
lock.unlockRead(stamp);
```

åŠ è§£å†™é”

```java
long stamp = lock.writeLock();
lock.unlockWrite(stamp);
```

ä¹è§‚è¯»ï¼ŒStampedLock æ”¯æŒ `tryOptimisticRead()` æ–¹æ³•ï¼ˆä¹è§‚è¯»ï¼‰ï¼Œè¯»å–å®Œæ¯•åéœ€è¦åšä¸€æ¬¡ æˆ³æ ¡éªŒ å¦‚æœæ ¡éªŒé€š è¿‡ï¼Œè¡¨ç¤ºè¿™æœŸé—´ç¡®å®æ²¡æœ‰å†™æ“ä½œï¼Œæ•°æ®å¯ä»¥å®‰å…¨ä½¿ç”¨ï¼Œå¦‚æœæ ¡éªŒæ²¡é€šè¿‡ï¼Œéœ€è¦é‡æ–°è·å–è¯»é”ï¼Œä¿è¯æ•°æ®å®‰å…¨ã€‚

```java
long stamp = lock.tryOptimisticRead();
// éªŒæˆ³
if(!lock.validate(stamp)){
    // é”å‡çº§
}
```



æä¾›ä¸€ä¸ª æ•°æ®å®¹å™¨ç±» å†…éƒ¨åˆ†åˆ«ä½¿ç”¨è¯»é”ä¿æŠ¤æ•°æ®çš„ `read()` æ–¹æ³•ï¼Œå†™é”ä¿æŠ¤æ•°æ®çš„ `write()` æ–¹æ³•

```java
class DataContainerStamped {
    private int data;
    private final StampedLock lock = new StampedLock();

    public DataContainerStamped(int data) {
        this.data = data;
    }

    public int read(int readTime) {
        long stamp = lock.tryOptimisticRead();
        log.debug("optimistic read locking...{}", stamp);
        sleep(readTime);
        if (lock.validate(stamp)) {
            log.debug("read finish...{}, data:{}", stamp, data);
            return data;
        }
        // é”å‡çº§ - è¯»é”
        log.debug("updating to read lock... {}", stamp);
        try {
            stamp = lock.readLock();
            log.debug("read lock {}", stamp);
            sleep(readTime);
            log.debug("read finish...{}, data:{}", stamp, data);
            return data;
        } finally {
            log.debug("read unlock {}", stamp);
            lock.unlockRead(stamp);
        }
    }

    public void write(int newData) {
        long stamp = lock.writeLock();
        log.debug("write lock {}", stamp);
        try {
            sleep(2);
            this.data = newData;
        } finally {
            log.debug("write unlock {}", stamp);
            lock.unlockWrite(stamp);
        }
    }
}
```

æµ‹è¯• `è¯»-è¯»` å¯ä»¥ä¼˜åŒ–

```java
public static void main(String[] args) {
    DataContainerStamped dataContainer = new DataContainerStamped(1);
    new Thread(() -> {
        dataContainer.read(1);
    }, "t1").start();
    sleep(0.5);
    new Thread(() -> {
        dataContainer.read(0);
    }, "t2").start();
}
```

```shell
# è¾“å‡ºç»“æœï¼Œå¯ä»¥çœ‹åˆ°å®é™…æ²¡æœ‰åŠ è¯»é”
14:18:53.106 c.DataContainerStamped [t1] - optimistic read locking...256
14:18:53.610 c.DataContainerStamped [t2] - optimistic read locking...256
14:18:53.611 c.DataContainerStamped [t2] - read finish...256, data:1
14:18:54.118 c.DataContainerStamped [t1] - read finish...256, data:1
```

æµ‹è¯• `è¯»-å†™` æ—¶ä¼˜åŒ–è¯»è¡¥åŠ è¯»é”

```java
public static void main(String[] args) {
    DataContainerStamped dataContainer = new DataContainerStamped(1);
    new Thread(() -> {
        dataContainer.read(1);
    }, "t1").start();
    sleep(0.5);
    new Thread(() -> {
        dataContainer.write(100);
    }, "t2").start();
}
```

```shell
# ç»“æœ
14:25:41.488 c.DataContainerStamped [t1] - optimistic read locking...256
14:25:41.990 c.DataContainerStamped [t2] - write lock 384
14:25:42.515 c.DataContainerStamped [t1] - updating to read lock... 256
14:25:43.996 c.DataContainerStamped [t2] - write unlock 384
14:25:43.996 c.DataContainerStamped [t1] - read lock 513
14:25:45.003 c.DataContainerStamped [t1] - read finish...513, data:100
14:25:45.004 c.DataContainerStamped [t1] - read unlock 513
```

> **æ³¨æ„**
>
> - StampedLock ä¸æ”¯æŒæ¡ä»¶å˜é‡
> - StampedLock ä¸æ”¯æŒå¯é‡å…¥





### 4. Semaphore

#### 1. åŸºæœ¬ä½¿ç”¨

[ËˆsÉ›mÉ™ËŒfÉ”r] ä¿¡å·é‡ï¼Œç”¨æ¥é™åˆ¶èƒ½åŒæ—¶è®¿é—®å…±äº«èµ„æºçš„çº¿ç¨‹ä¸Šé™ã€‚

```java
@Slf4j(topic = "c.TestSemaphore")
public class TestSemaphore {
    public static void main(String[] args) {
        // 1. åˆ›å»º semaphore å¯¹è±¡
        Semaphore semaphore = new Semaphore(3);

        // 2. 10ä¸ªçº¿ç¨‹åŒæ—¶è¿è¡Œ
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                try {
                    semaphore.acquire();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                try {
                    log.debug("running...");
                    sleep(1);
                    log.debug("end...");
                } finally {
                    semaphore.release();
                }
            }).start();
        }
    }
}
```

```shell
# ç»“æœ
14:37:01.272 c.TestSemaphore [Thread-2] - running...
14:37:01.273 c.TestSemaphore [Thread-1] - running...
14:37:01.265 c.TestSemaphore [Thread-0] - running...
14:37:02.291 c.TestSemaphore [Thread-1] - end...
14:37:02.291 c.TestSemaphore [Thread-2] - end...
14:37:02.291 c.TestSemaphore [Thread-0] - end...
14:37:02.291 c.TestSemaphore [Thread-3] - running...
14:37:02.291 c.TestSemaphore [Thread-4] - running...
14:37:02.291 c.TestSemaphore [Thread-5] - running...
14:37:03.300 c.TestSemaphore [Thread-4] - end...
14:37:03.300 c.TestSemaphore [Thread-6] - running...
14:37:03.300 c.TestSemaphore [Thread-5] - end...
14:37:03.301 c.TestSemaphore [Thread-3] - end...
14:37:03.301 c.TestSemaphore [Thread-7] - running...
14:37:03.301 c.TestSemaphore [Thread-8] - running...
14:37:04.307 c.TestSemaphore [Thread-8] - end...
14:37:04.307 c.TestSemaphore [Thread-7] - end...
14:37:04.307 c.TestSemaphore [Thread-6] - end...
14:37:04.307 c.TestSemaphore [Thread-9] - running...
14:37:05.312 c.TestSemaphore [Thread-9] - end...
```





#### 2. Semaphore åº”ç”¨

- ä½¿ç”¨ Semaphore é™æµï¼Œåœ¨è®¿é—®é«˜å³°æœŸæ—¶ï¼Œè®©è¯·æ±‚çº¿ç¨‹é˜»å¡ï¼Œé«˜å³°æœŸè¿‡å»å†é‡Šæ”¾è®¸å¯ï¼Œå½“ç„¶å®ƒåªé€‚åˆé™åˆ¶å•æœº çº¿ç¨‹æ•°é‡ï¼Œå¹¶ä¸”ä»…æ˜¯é™åˆ¶çº¿ç¨‹æ•°ï¼Œè€Œä¸æ˜¯é™åˆ¶èµ„æºæ•°ï¼ˆä¾‹å¦‚è¿æ¥æ•°ï¼Œè¯·å¯¹æ¯” Tomcat LimitLatch çš„å®ç°ï¼‰
- ç”¨ Semaphore å®ç°ç®€å•è¿æ¥æ± ï¼Œå¯¹æ¯”ã€äº«å…ƒæ¨¡å¼ã€ä¸‹çš„å®ç°ï¼ˆç”¨wait notifyï¼‰ï¼Œæ€§èƒ½å’Œå¯è¯»æ€§æ˜¾ç„¶æ›´å¥½ï¼Œ æ³¨æ„ä¸‹é¢çš„å®ç°ä¸­çº¿ç¨‹æ•°å’Œæ•°æ®åº“è¿æ¥æ•°æ˜¯ç›¸ç­‰çš„

```java
@Slf4j(topic = "c.Pool")
class Pool {
    // 1. è¿æ¥æ± å¤§å°
    private final int poolSize;
    
    // 2. è¿æ¥å¯¹è±¡æ•°ç»„
    private Connection[] connections;
    
    // 3. è¿æ¥çŠ¶æ€æ•°ç»„ 0 è¡¨ç¤ºç©ºé—²ï¼Œ 1 è¡¨ç¤ºç¹å¿™
    private AtomicIntegerArray states;
    private Semaphore semaphore;
    
    // 4. æ„é€ æ–¹æ³•åˆå§‹åŒ–
    public Pool(int poolSize) {
        this.poolSize = poolSize;
        // è®©è®¸å¯æ•°ä¸èµ„æºæ•°ä¸€è‡´
        this.semaphore = new Semaphore(poolSize);
        this.connections = new Connection[poolSize];
        this.states = new AtomicIntegerArray(new int[poolSize]);
        for (int i = 0; i < poolSize; i++) {
            connections[i] = new MockConnection("è¿æ¥" + (i+1));
        }
    }
    
    // 5. å€Ÿè¿æ¥
    public Connection borrow() {// t1, t2, t3
        // è·å–è®¸å¯
        try {
            semaphore.acquire(); // æ²¡æœ‰è®¸å¯çš„çº¿ç¨‹ï¼Œåœ¨æ­¤ç­‰å¾…
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        for (int i = 0; i < poolSize; i++) {
            // è·å–ç©ºé—²è¿æ¥
            if(states.get(i) == 0) {
                if (states.compareAndSet(i, 0, 1)) {
                    log.debug("borrow {}", connections[i]);
                    return connections[i];
                }
            }
        }
        // ä¸ä¼šæ‰§è¡Œåˆ°è¿™é‡Œ
        return null;
    }
    
    // 6. å½’è¿˜è¿æ¥
    public void free(Connection conn) {
        for (int i = 0; i < poolSize; i++) {
            if (connections[i] == conn) {
                states.set(i, 0);
                log.debug("free {}", conn);
                semaphore.release();
                break;
            }
        }
    }
}
```





#### 3. Semaphore åŸç†

##### 1. åŠ é”è§£é”æµç¨‹

Semaphore æœ‰ç‚¹åƒä¸€ä¸ªåœè½¦åœºï¼Œpermits å°±å¥½åƒåœè½¦ä½æ•°é‡ï¼Œå½“çº¿ç¨‹è·å¾—äº† permits å°±åƒæ˜¯è·å¾—äº†åœè½¦ä½ï¼Œç„¶å åœè½¦åœºæ˜¾ç¤ºç©ºä½™è½¦ä½å‡ä¸€

åˆšå¼€å§‹ï¼Œpermitsï¼ˆstateï¼‰ä¸º 3ï¼Œè¿™æ—¶ 5 ä¸ªçº¿ç¨‹æ¥è·å–èµ„æº

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192123391.png)

å‡è®¾å…¶ä¸­ Thread-1ï¼ŒThread-2ï¼ŒThread-4 cas ç«äº‰æˆåŠŸï¼Œè€Œ Thread-0 å’Œ Thread-3 ç«äº‰å¤±è´¥ï¼Œè¿›å…¥ AQS é˜Ÿåˆ— park é˜»å¡

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192123041.png)

è¿™æ—¶ Thread-4 é‡Šæ”¾äº† permitsï¼ŒçŠ¶æ€å¦‚ä¸‹

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192123771.png)

æ¥ä¸‹æ¥ Thread-0 ç«äº‰æˆåŠŸï¼Œpermits å†æ¬¡è®¾ç½®ä¸º 0ï¼Œè®¾ç½®è‡ªå·±ä¸º head èŠ‚ç‚¹ï¼Œæ–­å¼€åŸæ¥çš„ head èŠ‚ç‚¹ï¼Œunpark æ¥ ä¸‹æ¥çš„ Thread-3 èŠ‚ç‚¹ï¼Œä½†ç”±äº permits æ˜¯ 0ï¼Œå› æ­¤ Thread-3 åœ¨å°è¯•ä¸æˆåŠŸåå†æ¬¡è¿›å…¥ park çŠ¶æ€

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192123761.png)





##### 2. æºç åˆ†æ

```java
static final class NonfairSync extends Sync {
    private static final long serialVersionUID = -2694183684443567898L;
    NonfairSync(int permits) {
        // permits å³ state
        super(permits);
    }

    // Semaphore æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    public void acquire() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }
    // AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    public final void acquireSharedInterruptibly(int arg)
        throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        if (tryAcquireShared(arg) < 0)
            doAcquireSharedInterruptibly(arg);
    }

    // å°è¯•è·å¾—å…±äº«é”
    protected int tryAcquireShared(int acquires) {
        return nonfairTryAcquireShared(acquires);
    }

    // Sync ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    final int nonfairTryAcquireShared(int acquires) {
        for (;;) {
            int available = getState();
            int remaining = available - acquires; 
            if (
                // å¦‚æœè®¸å¯å·²ç»ç”¨å®Œ, è¿”å›è´Ÿæ•°, è¡¨ç¤ºè·å–å¤±è´¥, è¿›å…¥ doAcquireSharedInterruptibly
                remaining < 0 ||
                // å¦‚æœ cas é‡è¯•æˆåŠŸ, è¿”å›æ­£æ•°, è¡¨ç¤ºè·å–æˆåŠŸ
                compareAndSetState(available, remaining)
            ) {
                return remaining;
            }
        }
    }

    // AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    private void doAcquireSharedInterruptibly(int arg) throws InterruptedException {
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head) {
                    // å†æ¬¡å°è¯•è·å–è®¸å¯
                    int r = tryAcquireShared(arg);
                    if (r >= 0) {
                        // æˆåŠŸåæœ¬çº¿ç¨‹å‡ºé˜Ÿï¼ˆAQSï¼‰, æ‰€åœ¨ Nodeè®¾ç½®ä¸º head
                        // å¦‚æœ head.waitStatus == Node.SIGNAL ==> 0 æˆåŠŸ, ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ unpark
                        // å¦‚æœ head.waitStatus == 0 ==> Node.PROPAGATE 
                        // r è¡¨ç¤ºå¯ç”¨èµ„æºæ•°, ä¸º 0 åˆ™ä¸ä¼šç»§ç»­ä¼ æ’­
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        failed = false;
                        return;
                    }
                }
                // ä¸æˆåŠŸ, è®¾ç½®ä¸Šä¸€ä¸ªèŠ‚ç‚¹ waitStatus = Node.SIGNAL, ä¸‹è½®è¿›å…¥ park é˜»å¡
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

    // Semaphore æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    public void release() {
        sync.releaseShared(1);
    }

    // AQS ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }

    // Sync ç»§æ‰¿è¿‡æ¥çš„æ–¹æ³•, æ–¹ä¾¿é˜…è¯», æ”¾åœ¨æ­¤å¤„
    protected final boolean tryReleaseShared(int releases) {
        for (;;) {
            int current = getState();
            int next = current + releases;
            if (next < current) // overflow
                throw new Error("Maximum permit count exceeded");
            if (compareAndSetState(current, next))
                return true;
        }
    }
}
```



##### 3. ä¸ºä»€ä¹ˆè¦æœ‰ PROPAGATE

**1. æ—©æœŸæœ‰ bug**

- releaseShared æ–¹æ³•

```java
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

- doAcquireShared æ–¹æ³•

```java
private void doAcquireShared(int arg) {
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                    // è¿™é‡Œä¼šæœ‰ç©ºæ¡£
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}

```

- setHeadAndPropagate æ–¹æ³•

```java
private void setHeadAndPropagate(Node node, int propagate) {
    setHead(node);
    // æœ‰ç©ºé—²èµ„æº
    if (propagate > 0 && node.waitStatus != 0) {
        Node s = node.next;
        // ä¸‹ä¸€ä¸ª
        if (s == null || s.isShared())
            unparkSuccessor(node);
    }
}

```

- å‡è®¾å­˜åœ¨æŸæ¬¡å¾ªç¯ä¸­é˜Ÿåˆ—é‡Œæ’é˜Ÿçš„ç»“ç‚¹æƒ…å†µä¸º `head(-1)->t1(-1)->t2(-1)`
- å‡è®¾å­˜åœ¨å°†è¦ä¿¡å·é‡é‡Šæ”¾çš„ T3 å’Œ T4ï¼Œé‡Šæ”¾é¡ºåºä¸ºå…ˆ T3 å T4



**2. æ­£å¸¸æµç¨‹**

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192123691.png)



**3. äº§ç”Ÿ bug çš„æƒ…å†µ**

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192124468.png)



**4. ä¿®å¤å‰ç‰ˆæœ¬æ‰§è¡Œæµç¨‹**

1. T3 è°ƒç”¨ releaseShared(1)ï¼Œç›´æ¥è°ƒç”¨äº† unparkSuccessor(head)ï¼Œhead çš„ç­‰å¾…çŠ¶æ€ä» -1 å˜ä¸º 0
2. T1 ç”±äº T3 é‡Šæ”¾ä¿¡å·é‡è¢«å”¤é†’ï¼Œè°ƒç”¨ tryAcquireSharedï¼Œå‡è®¾è¿”å›å€¼ä¸º 0ï¼ˆè·å–é”æˆåŠŸï¼Œä½†æ²¡æœ‰å‰©ä½™èµ„æº é‡ï¼‰
3. T4 è°ƒç”¨ releaseShared(1)ï¼Œæ­¤æ—¶ head.waitStatus ä¸º 0ï¼ˆæ­¤æ—¶è¯»åˆ°çš„ head å’Œ 1 ä¸­ä¸ºåŒä¸€ä¸ªheadï¼‰ï¼Œä¸æ»¡è¶³ æ¡ä»¶ï¼Œå› æ­¤ä¸è°ƒç”¨ unparkSuccessor(head)
4. T1 è·å–ä¿¡å·é‡æˆåŠŸï¼Œè°ƒç”¨ setHeadAndPropagate æ—¶ï¼Œå› ä¸ºä¸æ»¡è¶³ propagate > 0ï¼ˆ2 çš„è¿”å›å€¼ä¹Ÿå°±æ˜¯ propagateï¼ˆå‰©ä½™èµ„æºé‡ï¼‰ == 0ï¼‰ï¼Œä»è€Œä¸ä¼šå”¤é†’åç»§ç»“ç‚¹ï¼Œ T2 çº¿ç¨‹å¾—ä¸åˆ°å”¤é†’



**5. bug ä¿®å¤å**

```java
private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; // Record old head for check below
    // è®¾ç½®è‡ªå·±ä¸º head
    setHead(node);
    // propagate è¡¨ç¤ºæœ‰å…±äº«èµ„æºï¼ˆä¾‹å¦‚å…±äº«è¯»é”æˆ–ä¿¡å·é‡ï¼‰
    // åŸ head waitStatus == Node.SIGNAL æˆ– Node.PROPAGATE
    // ç°åœ¨ head waitStatus == Node.SIGNAL æˆ– Node.PROPAGATE
    if (propagate > 0 || h == null || h.waitStatus < 0 ||
        (h = head) == null || h.waitStatus < 0) {
        Node s = node.next;
        // å¦‚æœæ˜¯æœ€åä¸€ä¸ªèŠ‚ç‚¹æˆ–è€…æ˜¯ç­‰å¾…å…±äº«è¯»é”çš„èŠ‚ç‚¹
        if (s == null || s.isShared()) {
            doReleaseShared();
        }
    }
}

private void doReleaseShared() {
    // å¦‚æœ head.waitStatus == Node.SIGNAL ==> 0 æˆåŠŸ, ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ unpark
    // å¦‚æœ head.waitStatus == 0 ==> Node.PROPAGATE 
    for (;;) {
        Node h = head;
        if (h != null && h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue; // loop to recheck cases
                unparkSuccessor(h);
            }
            else if (ws == 0 &&
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue; // loop on failed CAS
        }
        if (h == head) // loop if head changed
            break;
    }
}
```

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192124885.png)

1. T3 è°ƒç”¨ releaseShared()ï¼Œç›´æ¥è°ƒç”¨äº† unparkSuccessor(head)ï¼Œhead çš„ç­‰å¾…çŠ¶æ€ä» -1 å˜ä¸º 0
2. T1 ç”±äº T3 é‡Šæ”¾ä¿¡å·é‡è¢«å”¤é†’ï¼Œè°ƒç”¨ tryAcquireSharedï¼Œå‡è®¾è¿”å›å€¼ä¸º 0ï¼ˆè·å–é”æˆåŠŸï¼Œä½†æ²¡æœ‰å‰©ä½™èµ„æº é‡ï¼‰
3. T4 è°ƒç”¨ releaseShared()ï¼Œæ­¤æ—¶ head.waitStatus ä¸º 0ï¼ˆæ­¤æ—¶è¯»åˆ°çš„ head å’Œ 1 ä¸­ä¸ºåŒä¸€ä¸ª headï¼‰ï¼Œè°ƒç”¨ doReleaseShared() å°†ç­‰å¾…çŠ¶æ€ç½®ä¸º PROPAGATEï¼ˆ-3ï¼‰
4. T1 è·å–ä¿¡å·é‡æˆåŠŸï¼Œè°ƒç”¨ setHeadAndPropagate æ—¶ï¼Œè¯»åˆ° h.waitStatus < 0ï¼Œä»è€Œè°ƒç”¨ doReleaseShared() å”¤é†’ T2







### 5. CountdownLatch

ç”¨æ¥è¿›è¡Œçº¿ç¨‹åŒæ­¥åä½œï¼Œç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆå€’è®¡æ—¶ã€‚

å…¶ä¸­æ„é€ å‚æ•°ç”¨æ¥åˆå§‹åŒ–ç­‰å¾…è®¡æ•°å€¼ï¼Œawait() ç”¨æ¥ç­‰å¾…è®¡æ•°å½’é›¶ï¼ŒcountDown() ç”¨æ¥è®©è®¡æ•°å‡ä¸€

```java
public static void main(String[] args) throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(3);
    new Thread(() -> {
        log.debug("begin...");
        sleep(1);
        latch.countDown();
        log.debug("end...{}", latch.getCount());
    }).start();
    new Thread(() -> {
        log.debug("begin...");
        sleep(2);
        latch.countDown();
        log.debug("end...{}", latch.getCount());
    }).start();
    new Thread(() -> {
        log.debug("begin...");
        sleep(1.5);
        latch.countDown();
        log.debug("end...{}", latch.getCount());
    }).start();
    log.debug("waiting...");
    latch.await();
    log.debug("wait end...");
}
```

```shell
# ç»“æœ
18:51:56.961 c.TestCountDownLatch [main] - waiting...
18:51:56.961 c.TestCountDownLatch [Thread-1] - begin...
18:51:56.961 c.TestCountDownLatch [Thread-0] - begin...
18:51:56.961 c.TestCountDownLatch [Thread-2] - begin...
18:51:57.984 c.TestCountDownLatch [Thread-0] - end...2
18:51:58.490 c.TestCountDownLatch [Thread-2] - end...1
18:51:58.992 c.TestCountDownLatch [Thread-1] - end...0
18:51:58.992 c.TestCountDownLatch [main] - wait end...
```

å¯ä»¥é…åˆçº¿ç¨‹æ± ä½¿ç”¨ï¼Œæ”¹è¿›å¦‚ä¸‹

```java
public static void main(String[] args) throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(3);
    ExecutorService service = Executors.newFixedThreadPool(4);
    service.submit(() -> {
        log.debug("begin...");
        sleep(1);
        latch.countDown();
        log.debug("end...{}", latch.getCount());
    });
    service.submit(() -> {
        log.debug("begin...");
        sleep(1.5);
        latch.countDown();
        log.debug("end...{}", latch.getCount());
    });
    service.submit(() -> {
        log.debug("begin...");
        sleep(2);
        latch.countDown();
        log.debug("end...{}", latch.getCount());
    });
    service.submit(()->{
        try {
            log.debug("waiting...");
            latch.await();
            log.debug("wait end...");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });
}
```

```shell
# ç»“æœ
18:52:25.831 c.TestCountDownLatch [pool-1-thread-3] - begin... 
18:52:25.831 c.TestCountDownLatch [pool-1-thread-1] - begin... 
18:52:25.831 c.TestCountDownLatch [pool-1-thread-2] - begin... 
18:52:25.831 c.TestCountDownLatch [pool-1-thread-4] - waiting... 
18:52:26.835 c.TestCountDownLatch [pool-1-thread-1] - end...2 
18:52:27.335 c.TestCountDownLatch [pool-1-thread-2] - end...1 
18:52:27.835 c.TestCountDownLatch [pool-1-thread-3] - end...0 
18:52:27.835 c.TestCountDownLatch [pool-1-thread-4] - wait end... 
```



#### 1. åŒæ­¥ç­‰å¾…å¤šçº¿ç¨‹å‡†å¤‡å®Œæ¯•

```java
private static void test2() throws InterruptedException {
    AtomicInteger num = new AtomicInteger(0);
    ExecutorService service = Executors.newFixedThreadPool(10, (r) -> {
        return new Thread(r, "t" + num.getAndIncrement());
    });
    CountDownLatch latch = new CountDownLatch(10);
    String[] all = new String[10];
    Random r = new Random();
    for (int j = 0; j < 10; j++) {
        int x = j;
        service.submit(() -> {
            for (int i = 0; i <= 100; i++) {
                try {
                    Thread.sleep(r.nextInt(100));
                } catch (InterruptedException e) {
                }
                all[x] = Thread.currentThread().getName() + "(" + (i + "%") + ")";
                System.out.print("\r" + Arrays.toString(all));
            }
            latch.countDown();
        });
    }
    latch.await();
    System.out.println("\næ¸¸æˆå¼€å§‹...");
    service.shutdown();
}
```

```shell
# ç»“æœ
[t0(100%), t1(100%), t2(100%), t3(100%), t4(100%), t5(100%), t6(100%), t7(100%), t8(100%), t9(100%)]
æ¸¸æˆå¼€å§‹...
```





#### 2. åŒæ­¥ç­‰å¾…å¤šä¸ªè¿œç¨‹è°ƒç”¨ç»“æŸ

```java
@RestController
public class TestCountDownlatchController {

    @GetMapping("/order/{id}")
    public Map<String, Object> order(@PathVariable int id) {
        HashMap<String, Object> map = new HashMap<>();
        map.put("id", id);
        map.put("total", "2300.00");
        sleep(2000);
        return map;
    }

    @GetMapping("/product/{id}")
    public Map<String, Object> product(@PathVariable int id) {
        HashMap<String, Object> map = new HashMap<>();
        if (id == 1) {
            map.put("name", "å°çˆ±éŸ³ç®±");
            map.put("price", 300);
        } else if (id == 2) {
            map.put("name", "å°ç±³æ‰‹æœº");
            map.put("price", 2000);
        }
        map.put("id", id);
        sleep(1000);
        return map;
    }

    @GetMapping("/logistics/{id}")
    public Map<String, Object> logistics(@PathVariable int id) {
        HashMap<String, Object> map = new HashMap<>();
        map.put("id", id);
        map.put("name", "ä¸­é€šå¿«é€’");
        sleep(2500);
        return map;
    }

    private void sleep(int millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
private static void test3() throws InterruptedException, ExecutionException {
    RestTemplate restTemplate = new RestTemplate();
    log.debug("begin");
    ExecutorService service = Executors.newCachedThreadPool();
    CountDownLatch latch = new CountDownLatch(4);
    Future<Map<String,Object>> f1 = service.submit(() -> {
        Map<String, Object> response = restTemplate.getForObject("http://localhost:9090/order/{1}", Map.class, 1);
        return response;
    });
    Future<Map<String, Object>> f2 = service.submit(() -> {
        Map<String, Object> response1 = restTemplate.getForObject("http://localhost:9090/product/{1}", Map.class, 1);
        return response1;
    });
    Future<Map<String, Object>> f3 = service.submit(() -> {
        Map<String, Object> response1 = restTemplate.getForObject("http://localhost:9090/product/{1}", Map.class, 2);
        return response1;
    });
    Future<Map<String, Object>> f4 = service.submit(() -> {
        Map<String, Object> response3 = restTemplate.getForObject("http://localhost:9090/logistics/{1}", Map.class, 1);
        return response3;
    });

    System.out.println(f1.get());
    System.out.println(f2.get());
    System.out.println(f3.get());
    System.out.println(f4.get());
    log.debug("æ‰§è¡Œå®Œæ¯•");
    service.shutdown();
}
```

```shell
# ç»“æœ
19:30:06.768 c.TestCountDownLatch [main] - begin
{total=2300.00, id=1}
{price=300, name=å°çˆ±éŸ³ç®±, id=1}
{price=2000, name=å°ç±³æ‰‹æœº, id=2}
{name=ä¸­é€šå¿«é€’, id=1}
19:30:09.653 c.TestCountDownLatch [main] - æ‰§è¡Œå®Œæ¯•
```







### 6. CyclicBarrier

[ËˆsaÉªklÉªk ËˆbÃ¦riÉš]

å¾ªç¯æ …æ ï¼Œç”¨æ¥è¿›è¡Œçº¿ç¨‹åä½œï¼Œç­‰å¾…çº¿ç¨‹æ»¡è¶³æŸä¸ªè®¡æ•°ã€‚æ„é€ æ—¶è®¾ç½®ã€è®¡æ•°ä¸ªæ•°ã€ï¼Œæ¯ä¸ªçº¿ç¨‹æ‰§ è¡Œåˆ°æŸä¸ªéœ€è¦â€œåŒæ­¥â€çš„æ—¶åˆ»è°ƒç”¨ await() æ–¹æ³•è¿›è¡Œç­‰å¾…ï¼Œå½“ç­‰å¾…çš„çº¿ç¨‹æ•°æ»¡è¶³ã€è®¡æ•°ä¸ªæ•°ã€æ—¶ï¼Œç»§ç»­æ‰§è¡Œ

```java
public static void main(String[] args) {
    ExecutorService service = Executors.newFixedThreadPool(2);
    CyclicBarrier barrier = new CyclicBarrier(2, ()-> {
        log.debug("task1, task2 finish...");
    });
    for (int i = 0; i < 3; i++) { // task1  task2  task1
        service.submit(() -> {
            log.debug("task1 begin...");
            sleep(1);
            try {
                barrier.await(); // 2-1=1
            } catch (InterruptedException | BrokenBarrierException e) {
                e.printStackTrace();
            }
        });
        service.submit(() -> {
            log.debug("task2 begin...");
            sleep(2);
            try {
                barrier.await(); // 1-1=0
            } catch (InterruptedException | BrokenBarrierException e) {
                e.printStackTrace();
            }
        });
    }
    service.shutdown();
}
```

> **æ³¨æ„** CyclicBarrier ä¸ CountDownLatch çš„ä¸»è¦åŒºåˆ«åœ¨äº CyclicBarrier æ˜¯å¯ä»¥é‡ç”¨çš„ CyclicBarrier å¯ä»¥è¢«æ¯” å–»ä¸ºã€äººæ»¡å‘è½¦ã€







### 7. çº¿ç¨‹å®‰å…¨é›†åˆç±»æ¦‚è¿°

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192124230.png)

çº¿ç¨‹å®‰å…¨é›†åˆç±»å¯ä»¥åˆ†ä¸ºä¸‰å¤§ç±»ï¼š

- é—ç•™çš„çº¿ç¨‹å®‰å…¨é›†åˆå¦‚ `Hashtable` ï¼Œ `Vector`

- ä½¿ç”¨ Collections è£…é¥°çš„çº¿ç¨‹å®‰å…¨é›†åˆï¼Œå¦‚ï¼š
  - `Collections.synchronizedCollection`
  - `Collections.synchronizedList`
  - `Collections.synchronizedMap`
  - `Collections.synchronizedSet`
  - `Collections.synchronizedNavigableMap`
  - `Collections.synchronizedNavigableSet`
  - `Collections.synchronizedSortedMap`
  - `Collections.synchronizedSortedSet`

- `java.util.concurrent.*`

é‡ç‚¹ä»‹ç» `java.util.concurrent.*` ä¸‹çš„çº¿ç¨‹å®‰å…¨é›†åˆç±»ï¼Œå¯ä»¥å‘ç°å®ƒä»¬æœ‰è§„å¾‹ï¼Œé‡Œé¢åŒ…å«ä¸‰ç±»å…³é”®è¯ï¼š Blockingã€CopyOnWriteã€Concurrent

- Blocking å¤§éƒ¨åˆ†å®ç°åŸºäºé”ï¼Œå¹¶æä¾›ç”¨æ¥é˜»å¡çš„æ–¹æ³•
- CopyOnWrite ä¹‹ç±»å®¹å™¨ä¿®æ”¹å¼€é”€ç›¸å¯¹è¾ƒé‡
- Concurrent ç±»å‹çš„å®¹å™¨
  - å†…éƒ¨å¾ˆå¤šæ“ä½œä½¿ç”¨ cas ä¼˜åŒ–ï¼Œä¸€èˆ¬å¯ä»¥æä¾›è¾ƒé«˜ååé‡
  - å¼±ä¸€è‡´æ€§
    - éå†æ—¶å¼±ä¸€è‡´æ€§ï¼Œä¾‹å¦‚ï¼Œå½“åˆ©ç”¨è¿­ä»£å™¨éå†æ—¶ï¼Œå¦‚æœå®¹å™¨å‘ç”Ÿä¿®æ”¹ï¼Œè¿­ä»£å™¨ä»ç„¶å¯ä»¥ç»§ç»­è¿›è¡Œé å†ï¼Œè¿™æ—¶å†…å®¹æ˜¯æ—§çš„
    - æ±‚å¤§å°å¼±ä¸€è‡´æ€§ï¼Œsize æ“ä½œæœªå¿…æ˜¯ 100% å‡†ç¡®
    - è¯»å–å¼±ä¸€è‡´æ€§

> éå†æ—¶å¦‚æœå‘ç”Ÿäº†ä¿®æ”¹ï¼Œå¯¹äºéå®‰å…¨å®¹å™¨æ¥è®²ï¼Œä½¿ç”¨ fail-fast æœºåˆ¶ä¹Ÿå°±æ˜¯è®©éå†ç«‹åˆ»å¤±è´¥ï¼ŒæŠ›å‡º ConcurrentModificationExceptionï¼Œä¸å†ç»§ç»­éå†







### 8. ConcurrentHashMap

#### 1. ç»ƒä¹ ï¼šå•è¯è®¡æ•°

ç”Ÿæˆæµ‹è¯•æ•°æ®

```java
static final String ALPHA = "abcedfghijklmnopqrstuvwxyz";
public static void main(String[] args) {
    int length = ALPHA.length();
    int count = 200;
    List<String> list = new ArrayList<>(length * count);
    for (int i = 0; i < length; i++) {
        char ch = ALPHA.charAt(i);
        for (int j = 0; j < count; j++) {
            list.add(String.valueOf(ch));
        }
    }
    Collections.shuffle(list);
    for (int i = 0; i < 26; i++) {
        try (PrintWriter out = new PrintWriter(
            new OutputStreamWriter(
                new FileOutputStream("tmp/" + (i+1) + ".txt")))) {
            String collect = list.subList(i * count, (i + 1) * count).stream()
                .collect(Collectors.joining("\n"));
            out.print(collect);
        } catch (IOException e) {
        }
    }
}
```

æ¨¡ç‰ˆä»£ç ï¼Œæ¨¡ç‰ˆä»£ç ä¸­å°è£…äº†å¤šçº¿ç¨‹è¯»å–æ–‡ä»¶çš„ä»£ç 

```java
private static <V> void demo(Supplier<Map<String, V>> supplier, BiConsumer<Map<String, V>, List<String>> consumer) {
    Map<String, V> counterMap = supplier.get();
    // key value
    // a   200
    // b   200
    List<Thread> ts = new ArrayList<>();
    for (int i = 1; i <= 26; i++) {
        int idx = i;
        Thread thread = new Thread(() -> {
            List<String> words = readFromFile(idx);
            consumer.accept(counterMap, words);
        });
        ts.add(thread);
    }

    ts.forEach(t -> t.start());
    ts.forEach(t -> {
        try {
            t.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });

    System.out.println(counterMap);
}

public static List<String> readFromFile(int i) {
    ArrayList<String> words = new ArrayList<>();
    try (BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream("tmp/" + i + ".txt")))) {
        while (true) {
            String word = in.readLine();
            if (word == null) {
                break;
            }
            words.add(word);
        }
        return words;
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
```

ä½ è¦åšçš„æ˜¯å®ç°ä¸¤ä¸ªå‚æ•°

- ä¸€æ˜¯æä¾›ä¸€ä¸ª map é›†åˆï¼Œç”¨æ¥å­˜æ”¾æ¯ä¸ªå•è¯çš„è®¡æ•°ç»“æœï¼Œkey ä¸ºå•è¯ï¼Œvalue ä¸ºè®¡æ•°
- äºŒæ˜¯æä¾›ä¸€ç»„æ“ä½œï¼Œä¿è¯è®¡æ•°çš„å®‰å…¨æ€§ï¼Œä¼šä¼ é€’ map é›†åˆä»¥åŠ å•è¯ List

**é”™è¯¯å®ç°**

```java
public static void main(String[] args) {
    demo(
        // åˆ›å»º map é›†åˆ
        // åˆ›å»º ConcurrentHashMap å¯¹ä¸å¯¹ï¼Ÿ
        () -> new HashMap<String, Integer>(),
        // è¿›è¡Œè®¡æ•°
        (map, words) -> {
            for (String word : words) {
                Integer counter = map.get(word);
                int newValue = counter == null ? 1 : counter + 1;
                map.put(word, newValue);
            }
        }
    );
}
```

**å‚è€ƒè§£ç­”1**

```java
demo(
    () -> new ConcurrentHashMap<String, LongAdder>(),
    (map, words) -> {
        for (String word : words) {
            // æ³¨æ„ä¸èƒ½ä½¿ç”¨ putIfAbsentï¼Œæ­¤æ–¹æ³•è¿”å›çš„æ˜¯ä¸Šä¸€æ¬¡çš„ valueï¼Œé¦–æ¬¡è°ƒç”¨è¿”å› null
            map.computeIfAbsent(word, (key) -> new LongAdder()).increment();
        }
    }
);
```

**å‚è€ƒè§£ç­”2**

```java
demo(
    () -> new ConcurrentHashMap<String, Integer>(),
    (map, words) -> {
        for (String word : words) {
            // å‡½æ•°å¼ç¼–ç¨‹ï¼Œæ— éœ€åŸå­å˜é‡
            map.merge(word, 1, Integer::sum);
        }
    }
);
```





#### 2. ConcurrentHashMap åŸç†

##### 1. JDK 7 HashMap å¹¶å‘æ­»é“¾

**1. æµ‹è¯•ä»£ç **

æ³¨æ„

- è¦åœ¨ JDK 7 ä¸‹è¿è¡Œï¼Œå¦åˆ™æ‰©å®¹æœºåˆ¶å’Œ hash çš„è®¡ç®—æ–¹æ³•éƒ½å˜äº†
- ä»¥ä¸‹æµ‹è¯•ä»£ç æ˜¯ç²¾å¿ƒå‡†å¤‡çš„ï¼Œä¸è¦éšä¾¿æ”¹åŠ¨

```java
public static void main(String[] args) {
    // æµ‹è¯• java 7 ä¸­å“ªäº›æ•°å­—çš„ hash ç»“æœç›¸ç­‰
    System.out.println("é•¿åº¦ä¸º16æ—¶ï¼Œæ¡¶ä¸‹æ ‡ä¸º1çš„key");
    for (int i = 0; i < 64; i++) {
        if (hash(i) % 16 == 1) {
            System.out.println(i);
        }
    }
    System.out.println("é•¿åº¦ä¸º32æ—¶ï¼Œæ¡¶ä¸‹æ ‡ä¸º1çš„key");
    for (int i = 0; i < 64; i++) {
        if (hash(i) % 32 == 1) {
            System.out.println(i);
        }
    }
    // 1, 35, 16, 50 å½“å¤§å°ä¸º16æ—¶ï¼Œå®ƒä»¬åœ¨ä¸€ä¸ªæ¡¶å†…
    final HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
    // æ”¾ 12 ä¸ªå…ƒç´ 
    map.put(2, null);
    map.put(3, null);
    map.put(4, null);
    map.put(5, null);
    map.put(6, null);
    map.put(7, null);
    map.put(8, null);
    map.put(9, null);
    map.put(10, null);
    map.put(16, null);
    map.put(35, null);
    map.put(1, null);
    System.out.println("æ‰©å®¹å‰å¤§å°[main]:"+map.size());
    new Thread() {
        @Override
        public void run() {
            // æ”¾ç¬¬ 13 ä¸ªå…ƒç´ , å‘ç”Ÿæ‰©å®¹
            map.put(50, null);
            System.out.println("æ‰©å®¹åå¤§å°[Thread-0]:"+map.size());
        }
    }.start();
    new Thread() {
        @Override
        public void run() {
            // æ”¾ç¬¬ 13 ä¸ªå…ƒç´ , å‘ç”Ÿæ‰©å®¹
            map.put(50, null);
            System.out.println("æ‰©å®¹åå¤§å°[Thread-1]:"+map.size());
        }
    }.start();
}

final static int hash(Object k) {
    int h = 0;
    if (0 != h && k instanceof String) {
        return sun.misc.Hashing.stringHash32((String) k);
    }
    h ^= k.hashCode();
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}
```



**2. æ­»é“¾å¤ç°**

è°ƒè¯•å·¥å…·ä½¿ç”¨ idea

åœ¨ HashMap æºç  590 è¡ŒåŠ æ–­ç‚¹

```java
int newCapacity = newTable.length;
```

æ–­ç‚¹çš„æ¡ä»¶å¦‚ä¸‹ï¼Œç›®çš„æ˜¯è®© HashMap åœ¨æ‰©å®¹ä¸º 32 æ—¶ï¼Œå¹¶ä¸”çº¿ç¨‹ä¸º Thread-0 æˆ– Thread-1 æ—¶åœä¸‹æ¥

```java
newTable.length==32 &&
    (
    Thread.currentThread().getName().equals("Thread-0")||
    Thread.currentThread().getName().equals("Thread-1")
)
```

æ–­ç‚¹æš‚åœæ–¹å¼é€‰æ‹© Threadï¼Œå¦åˆ™åœ¨è°ƒè¯• Thread-0 æ—¶ï¼ŒThread-1 æ— æ³•æ¢å¤è¿è¡Œ

è¿è¡Œä»£ç ï¼Œç¨‹åºåœ¨é¢„æ–™çš„æ–­ç‚¹ä½ç½®åœäº†ä¸‹æ¥ï¼Œè¾“å‡º

```java
é•¿åº¦ä¸º16æ—¶ï¼Œæ¡¶ä¸‹æ ‡ä¸º1çš„key 
1 
16 
35 
50 
é•¿åº¦ä¸º32æ—¶ï¼Œæ¡¶ä¸‹æ ‡ä¸º1çš„key 
1 
35 
æ‰©å®¹å‰å¤§å°[main]:12 
```

æ¥ä¸‹æ¥è¿›å…¥æ‰©å®¹æµç¨‹è°ƒè¯•

åœ¨ HashMap æºç  594 è¡ŒåŠ æ–­ç‚¹

```java
Entry<K,V> next = e.next; // 593
if (rehash) // 594
// ...
```

è¿™æ˜¯ä¸ºäº†è§‚å¯Ÿ e èŠ‚ç‚¹å’Œ next èŠ‚ç‚¹çš„çŠ¶æ€ï¼ŒThread-0 å•æ­¥æ‰§è¡Œåˆ° 594 è¡Œï¼Œå† 594 å¤„å†æ·»åŠ ä¸€ä¸ªæ–­ç‚¹ï¼ˆæ¡ä»¶ Thread.currentThread().getName().equals("Thread-0")ï¼‰

è¿™æ—¶å¯ä»¥åœ¨ Variables é¢æ¿è§‚å¯Ÿåˆ° e å’Œ next å˜é‡ï¼Œä½¿ç”¨ `view as -> Object` æŸ¥çœ‹èŠ‚ç‚¹çŠ¶æ€

```java
e 			(1)->(35)->(16)->null 
next 		(35)->(16)->null 
```

åœ¨ Threads é¢æ¿é€‰ä¸­ Thread-1 æ¢å¤è¿è¡Œï¼Œå¯ä»¥çœ‹åˆ°æ§åˆ¶å°è¾“å‡ºæ–°çš„å†…å®¹å¦‚ä¸‹ï¼ŒThread-1 æ‰©å®¹å·²å®Œæˆ

```java
newTable[1] 	(35)->(1)->null
```

```java
æ‰©å®¹åå¤§å°:13
```

è¿™æ—¶ Thread-0 è¿˜åœåœ¨ 594 å¤„ï¼Œ Variables é¢æ¿å˜é‡çš„çŠ¶æ€å·²ç»å˜åŒ–ä¸º

```java
e 			(1)->null 
next 		(35)->(1)->null
```

ä¸ºä»€ä¹ˆå‘¢ï¼Œå› ä¸º Thread-1 æ‰©å®¹æ—¶é“¾è¡¨ä¹Ÿæ˜¯ååŠ å…¥çš„å…ƒç´ æ”¾å…¥é“¾è¡¨å¤´ï¼Œå› æ­¤é“¾è¡¨å°±å€’è¿‡æ¥äº†ï¼Œä½† Thread-1 è™½ç„¶ç»“ æœæ­£ç¡®ï¼Œä½†å®ƒç»“æŸå Thread-0 è¿˜è¦ç»§ç»­è¿è¡Œ

æ¥ä¸‹æ¥å°±å¯ä»¥å•æ­¥è°ƒè¯•ï¼ˆF8ï¼‰è§‚å¯Ÿæ­»é“¾çš„äº§ç”Ÿäº†

ä¸‹ä¸€è½®å¾ªç¯åˆ° 594ï¼Œå°† e æ¬è¿åˆ° newTable é“¾è¡¨å¤´

```java
newTable[1] 	(1)->null 
e 				(35)->(1)->null 
next 			(1)->null 
```

ä¸‹ä¸€è½®å¾ªç¯åˆ° 594ï¼Œå°† e æ¬è¿åˆ° newTable é“¾è¡¨å¤´

```java
newTable[1] 	(35)->(1)->null 
e 				(1)->null 
next null 
```

å†çœ‹çœ‹æºç 

```java
e.next = newTable[1];
// è¿™æ—¶ e (1,35)
// è€Œ newTable[1] (35,1)->(1,35) å› ä¸ºæ˜¯åŒä¸€ä¸ªå¯¹è±¡

newTable[1] = e; 
// å†å°è¯•å°† e ä½œä¸ºé“¾è¡¨å¤´, æ­»é“¾å·²æˆ

e = next;
// è™½ç„¶ next æ˜¯ null, ä¼šè¿›å…¥ä¸‹ä¸€ä¸ªé“¾è¡¨çš„å¤åˆ¶, ä½†æ­»é“¾å·²ç»å½¢æˆäº†
```



**3. æºç åˆ†æ**

HashMap çš„å¹¶å‘æ­»é“¾å‘ç”Ÿåœ¨æ‰©å®¹æ—¶

```java
// å°† table è¿ç§»è‡³ newTable
void transfer(Entry[] newTable, boolean rehash) { 
    int newCapacity = newTable.length;
    for (Entry<K,V> e : table) {
        while(null != e) {
            Entry<K,V> next = e.next;
            // 1 å¤„
            if (rehash) {
                e.hash = null == e.key ? 0 : hash(e.key);
            }
            int i = indexFor(e.hash, newCapacity);
            // 2 å¤„
            // å°†æ–°å…ƒç´ åŠ å…¥ newTable[i], åŸ newTable[i] ä½œä¸ºæ–°å…ƒç´ çš„ next
            e.next = newTable[i];
            newTable[i] = e;
            e = next;
        }
    }
}
```

å‡è®¾ map ä¸­åˆå§‹å…ƒç´ æ˜¯

```java
åŸå§‹é“¾è¡¨ï¼Œæ ¼å¼ï¼š[ä¸‹æ ‡] (key,next)
[1] (1,35)->(35,16)->(16,null)
   
çº¿ç¨‹ a æ‰§è¡Œåˆ° 1 å¤„ ï¼Œæ­¤æ—¶å±€éƒ¨å˜é‡ e ä¸º (1,35)ï¼Œè€Œå±€éƒ¨å˜é‡ next ä¸º (35,16) çº¿ç¨‹ a æŒ‚èµ·
çº¿ç¨‹ b å¼€å§‹æ‰§è¡Œ
ç¬¬ä¸€æ¬¡å¾ªç¯
[1] (1,null)
    
ç¬¬äºŒæ¬¡å¾ªç¯
[1] (35,1)->(1,null)
    
ç¬¬ä¸‰æ¬¡å¾ªç¯
[1] (35,1)->(1,null)
[17] (16,null)
    
åˆ‡æ¢å›çº¿ç¨‹ aï¼Œæ­¤æ—¶å±€éƒ¨å˜é‡ e å’Œ next è¢«æ¢å¤ï¼Œå¼•ç”¨æ²¡å˜ä½†å†…å®¹å˜äº†ï¼še çš„å†…å®¹è¢«æ”¹ä¸º (1,null)ï¼Œè€Œ next çš„å†…
å®¹è¢«æ”¹ä¸º (35,1) å¹¶é“¾å‘ (1,null)
ç¬¬ä¸€æ¬¡å¾ªç¯
[1] (1,null)
    
ç¬¬äºŒæ¬¡å¾ªç¯ï¼Œæ³¨æ„è¿™æ—¶ e æ˜¯ (35,1) å¹¶é“¾å‘ (1,null) æ‰€ä»¥ next åˆæ˜¯ (1,null)
[1] (35,1)->(1,null)
    
ç¬¬ä¸‰æ¬¡å¾ªç¯ï¼Œe æ˜¯ (1,null)ï¼Œè€Œ next æ˜¯ nullï¼Œä½† e è¢«æ”¾å…¥é“¾è¡¨å¤´ï¼Œè¿™æ · e.next å˜æˆäº† 35 ï¼ˆ2 å¤„ï¼‰
[1] (1,35)->(35,1)->(1,35)
å·²ç»æ˜¯æ­»é“¾äº†
```



**4. å°ç»“**

- ç©¶å…¶åŸå› ï¼Œæ˜¯å› ä¸ºåœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ä½¿ç”¨äº†éçº¿ç¨‹å®‰å…¨çš„ map é›†åˆ
- JDK 8 è™½ç„¶å°†æ‰©å®¹ç®—æ³•åšäº†è°ƒæ•´ï¼Œä¸å†å°†å…ƒç´ åŠ å…¥é“¾è¡¨å¤´ï¼ˆè€Œæ˜¯ä¿æŒä¸æ‰©å®¹å‰ä¸€æ ·çš„é¡ºåºï¼‰ï¼Œä½†ä»ä¸æ„å‘³ç€èƒ½ å¤Ÿåœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹èƒ½å¤Ÿå®‰å…¨æ‰©å®¹ï¼Œè¿˜ä¼šå‡ºç°å…¶å®ƒé—®é¢˜ï¼ˆå¦‚æ‰©å®¹ä¸¢æ•°æ®ï¼‰





##### 2. JDK8 ConcurrentHashMap

**1. é‡è¦å±æ€§å’Œå†…éƒ¨ç±»**

```java
// é»˜è®¤ä¸º 0
// å½“åˆå§‹åŒ–æ—¶, ä¸º -1
// å½“æ‰©å®¹æ—¶, ä¸º -(1 + æ‰©å®¹çº¿ç¨‹æ•°)
// å½“åˆå§‹åŒ–æˆ–æ‰©å®¹å®Œæˆåï¼Œä¸º ä¸‹ä¸€æ¬¡çš„æ‰©å®¹çš„é˜ˆå€¼å¤§å°
private transient volatile int sizeCtl;

// æ•´ä¸ª ConcurrentHashMap å°±æ˜¯ä¸€ä¸ª Node[]
static class Node<K,V> implements Map.Entry<K,V> {}

// hash è¡¨
transient volatile Node<K,V>[] table;

// æ‰©å®¹æ—¶çš„ æ–° hash è¡¨
private transient volatile Node<K,V>[] nextTable;

// æ‰©å®¹æ—¶å¦‚æœæŸä¸ª bin è¿ç§»å®Œæ¯•, ç”¨ ForwardingNode ä½œä¸ºæ—§ table bin çš„å¤´ç»“ç‚¹
static final class ForwardingNode<K,V> extends Node<K,V> {}

// ç”¨åœ¨ compute ä»¥åŠ computeIfAbsent æ—¶, ç”¨æ¥å ä½, è®¡ç®—å®Œæˆåæ›¿æ¢ä¸ºæ™®é€š Node
static final class ReservationNode<K,V> extends Node<K,V> {}

// ä½œä¸º treebin çš„å¤´èŠ‚ç‚¹, å­˜å‚¨ root å’Œ first
static final class TreeBin<K,V> extends Node<K,V> {}

// ä½œä¸º treebin çš„èŠ‚ç‚¹, å­˜å‚¨ parent, left, right
static final class TreeNode<K,V> extends Node<K,V> {}
```



**2. é‡è¦æ–¹æ³•**

```java
// è·å– Node[] ä¸­ç¬¬ i ä¸ª Node
static final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i)
 
// cas ä¿®æ”¹ Node[] ä¸­ç¬¬ i ä¸ª Node çš„å€¼, c ä¸ºæ—§å€¼, v ä¸ºæ–°å€¼
static final <K,V> boolean casTabAt(Node<K,V>[] tab, int i, Node<K,V> c, Node<K,V> v)
 
// ç›´æ¥ä¿®æ”¹ Node[] ä¸­ç¬¬ i ä¸ª Node çš„å€¼, v ä¸ºæ–°å€¼
static final <K,V> void setTabAt(Node<K,V>[] tab, int i, Node<K,V> v)
```



**3. æ„é€ å™¨åˆ†æ**

å¯ä»¥çœ‹åˆ°å®ç°äº†æ‡’æƒ°åˆå§‹åŒ–ï¼Œåœ¨æ„é€ æ–¹æ³•ä¸­ä»…ä»…è®¡ç®—äº† table çš„å¤§å°ï¼Œä»¥ååœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨æ—¶æ‰ä¼šçœŸæ­£åˆ›å»º

```java
public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {
    if (!(loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0)
        throw new IllegalArgumentException();
    if (initialCapacity < concurrencyLevel) // Use at least as many bins
        initialCapacity = concurrencyLevel; // as estimated threads
    long size = (long)(1.0 + (long)initialCapacity / loadFactor);
    // tableSizeFor ä»ç„¶æ˜¯ä¿è¯è®¡ç®—çš„å¤§å°æ˜¯ 2^n, å³ 16,32,64 ... 
    int cap = (size >= (long)MAXIMUM_CAPACITY) ?
        MAXIMUM_CAPACITY : tableSizeFor((int)size);
    this.sizeCtl = cap;
}
```



**4. get æµç¨‹**

```java
public V get(Object key) {
    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
    // spread æ–¹æ³•èƒ½ç¡®ä¿è¿”å›ç»“æœæ˜¯æ­£æ•°
    int h = spread(key.hashCode());
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (e = tabAt(tab, (n - 1) & h)) != null) {
        // å¦‚æœå¤´ç»“ç‚¹å·²ç»æ˜¯è¦æŸ¥æ‰¾çš„ key
        if ((eh = e.hash) == h) {
            if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                return e.val;
        }
        // hash ä¸ºè´Ÿæ•°è¡¨ç¤ºè¯¥ bin åœ¨æ‰©å®¹ä¸­æˆ–æ˜¯ treebin, è¿™æ—¶è°ƒç”¨ find æ–¹æ³•æ¥æŸ¥æ‰¾
        else if (eh < 0)
            return (p = e.find(h, key)) != null ? p.val : null;
        // æ­£å¸¸éå†é“¾è¡¨, ç”¨ equals æ¯”è¾ƒ
        while ((e = e.next) != null) {
            if (e.hash == h &&
                ((ek = e.key) == key || (ek != null && key.equals(ek))))
                return e.val;
        }
    }
    return null;
}
```



**5. put æµç¨‹**

ä»¥ä¸‹æ•°ç»„ç®€ç§°ï¼ˆtableï¼‰ï¼Œé“¾è¡¨ç®€ç§°ï¼ˆbinï¼‰

```java
public V put(K key, V value) {
    return putVal(key, value, false);
}

final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    // å…¶ä¸­ spread æ–¹æ³•ä¼šç»¼åˆé«˜ä½ä½ä½, å…·æœ‰æ›´å¥½çš„ hash æ€§
    int hash = spread(key.hashCode());
    int binCount = 0;
    for (Node<K,V>[] tab = table;;) {
        // f æ˜¯é“¾è¡¨å¤´èŠ‚ç‚¹
        // fh æ˜¯é“¾è¡¨å¤´ç»“ç‚¹çš„ hash
        // i æ˜¯é“¾è¡¨åœ¨ table ä¸­çš„ä¸‹æ ‡
        Node<K,V> f; int n, i, fh;
        // è¦åˆ›å»º table
        if (tab == null || (n = tab.length) == 0)
            // åˆå§‹åŒ– table ä½¿ç”¨äº† cas, æ— éœ€ synchronized åˆ›å»ºæˆåŠŸ, è¿›å…¥ä¸‹ä¸€è½®å¾ªç¯
            tab = initTable();
        // è¦åˆ›å»ºé“¾è¡¨å¤´èŠ‚ç‚¹
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
            // æ·»åŠ é“¾è¡¨å¤´ä½¿ç”¨äº† cas, æ— éœ€ synchronized
            if (casTabAt(tab, i, null,
                         new Node<K,V>(hash, key, value, null)))
                break;
        }
        // å¸®å¿™æ‰©å®¹
        else if ((fh = f.hash) == MOVED)
            // å¸®å¿™ä¹‹å, è¿›å…¥ä¸‹ä¸€è½®å¾ªç¯
            tab = helpTransfer(tab, f);
        else {
            V oldVal = null;
            // é”ä½é“¾è¡¨å¤´èŠ‚ç‚¹
            synchronized (f) {
                // å†æ¬¡ç¡®è®¤é“¾è¡¨å¤´èŠ‚ç‚¹æ²¡æœ‰è¢«ç§»åŠ¨
                if (tabAt(tab, i) == f) {
                    // é“¾è¡¨
                    if (fh >= 0) {
                        binCount = 1;
                        // éå†é“¾è¡¨
                        for (Node<K,V> e = f;; ++binCount) {
                            K ek;
                            // æ‰¾åˆ°ç›¸åŒçš„ key
                            if (e.hash == hash &&
                                ((ek = e.key) == key ||
                                 (ek != null && key.equals(ek)))) {
                                oldVal = e.val;
                                // æ›´æ–°
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node<K,V> pred = e;
                            // å·²ç»æ˜¯æœ€åçš„èŠ‚ç‚¹äº†, æ–°å¢ Node, è¿½åŠ è‡³é“¾è¡¨å°¾
                            if ((e = e.next) == null) {
                                pred.next = new Node<K,V>(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    // çº¢é»‘æ ‘
                    else if (f instanceof TreeBin) {
                        Node<K,V> p;
                        binCount = 2;
                        // putTreeVal ä¼šçœ‹ key æ˜¯å¦å·²ç»åœ¨æ ‘ä¸­, æ˜¯, åˆ™è¿”å›å¯¹åº”çš„ TreeNode
                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                              value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
                // é‡Šæ”¾é“¾è¡¨å¤´èŠ‚ç‚¹çš„é”
            }

            if (binCount != 0) { 
                if (binCount >= TREEIFY_THRESHOLD)
                    // å¦‚æœé“¾è¡¨é•¿åº¦ >= æ ‘åŒ–é˜ˆå€¼(8), è¿›è¡Œé“¾è¡¨è½¬ä¸ºçº¢é»‘æ ‘
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    // å¢åŠ  size è®¡æ•°
    addCount(1L, binCount);
    return null;
}

private final Node<K,V>[] initTable() {
    Node<K,V>[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        if ((sc = sizeCtl) < 0)
            Thread.yield();
        // å°è¯•å°† sizeCtl è®¾ç½®ä¸º -1ï¼ˆè¡¨ç¤ºåˆå§‹åŒ– tableï¼‰
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            // è·å¾—é”, åˆ›å»º table, è¿™æ—¶å…¶å®ƒçº¿ç¨‹ä¼šåœ¨ while() å¾ªç¯ä¸­ yield ç›´è‡³ table åˆ›å»º
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                    table = tab = nt;
                    sc = n - (n >>> 2);
                }
            } finally {
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}

// check æ˜¯ä¹‹å‰ binCount çš„ä¸ªæ•°
private final void addCount(long x, int check) {
    CounterCell[] as; long b, s;
    if (
        // å·²ç»æœ‰äº† counterCells, å‘ cell ç´¯åŠ 
        (as = counterCells) != null ||
        // è¿˜æ²¡æœ‰, å‘ baseCount ç´¯åŠ 
        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)
    ) {
        CounterCell a; long v; int m;
        boolean uncontended = true;
        if (
            // è¿˜æ²¡æœ‰ counterCells
            as == null || (m = as.length - 1) < 0 ||
            // è¿˜æ²¡æœ‰ cell
            (a = as[ThreadLocalRandom.getProbe() & m]) == null ||
            // cell cas å¢åŠ è®¡æ•°å¤±è´¥
            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))
        ) {
            // åˆ›å»ºç´¯åŠ å•å…ƒæ•°ç»„å’Œcell, ç´¯åŠ é‡è¯•
            fullAddCount(x, uncontended);
            return;
        }
        if (check <= 1)
            return;
        // è·å–å…ƒç´ ä¸ªæ•°
        s = sumCount();
    }
    if (check >= 0) {
        Node<K,V>[] tab, nt; int n, sc;
        while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&
               (n = tab.length) < MAXIMUM_CAPACITY) {
            int rs = resizeStamp(n);
            if (sc < 0) {
                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                    transferIndex <= 0)
                    break;
                // newtable å·²ç»åˆ›å»ºäº†ï¼Œå¸®å¿™æ‰©å®¹
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                    transfer(tab, nt);
            }
            // éœ€è¦æ‰©å®¹ï¼Œè¿™æ—¶ newtable æœªåˆ›å»º
            else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                         (rs << RESIZE_STAMP_SHIFT) + 2))
                transfer(tab, null);
            s = sumCount();
        }
    }
}

```



**6. size è®¡ç®—æµç¨‹**

size è®¡ç®—å®é™…å‘ç”Ÿåœ¨ putï¼Œremove æ”¹å˜é›†åˆå…ƒç´ çš„æ“ä½œä¹‹ä¸­

- æ²¡æœ‰ç«äº‰å‘ç”Ÿï¼Œå‘ baseCount ç´¯åŠ è®¡æ•°
-  æœ‰ç«äº‰å‘ç”Ÿï¼Œæ–°å»º counterCellsï¼Œå‘å…¶ä¸­çš„ä¸€ä¸ª cell ç´¯åŠ è®¡æ•°
  - counterCells åˆå§‹æœ‰ä¸¤ä¸ª cell
  - å¦‚æœè®¡æ•°ç«äº‰æ¯”è¾ƒæ¿€çƒˆï¼Œä¼šåˆ›å»ºæ–°çš„ cell æ¥ç´¯åŠ è®¡æ•°

```java
public int size() {
    long n = sumCount();
    return ((n < 0L) ? 0 :
            (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
            (int)n);
}

final long sumCount() {
    CounterCell[] as = counterCells; CounterCell a;
    // å°† baseCount è®¡æ•°ä¸æ‰€æœ‰ cell è®¡æ•°ç´¯åŠ 
    long sum = baseCount;
    if (as != null) {
        for (int i = 0; i < as.length; ++i) {
            if ((a = as[i]) != null)
                sum += a.value;
        }
    }
    return sum;
}

```

Java 8 æ•°ç»„ï¼ˆNodeï¼‰ +ï¼ˆ é“¾è¡¨ Node | çº¢é»‘æ ‘ TreeNode ï¼‰ ä»¥ä¸‹æ•°ç»„ç®€ç§°ï¼ˆtableï¼‰ï¼Œé“¾è¡¨ç®€ç§°ï¼ˆbinï¼‰

- åˆå§‹åŒ–ï¼Œä½¿ç”¨ cas æ¥ä¿è¯å¹¶å‘å®‰å…¨ï¼Œæ‡’æƒ°åˆå§‹åŒ– table
- æ ‘åŒ–ï¼Œå½“ table.length < 64 æ—¶ï¼Œå…ˆå°è¯•æ‰©å®¹ï¼Œè¶…è¿‡ 64 æ—¶ï¼Œå¹¶ä¸” bin.length > 8 æ—¶ï¼Œä¼šå°†é“¾è¡¨æ ‘åŒ–ï¼Œæ ‘åŒ–è¿‡ç¨‹ ä¼šç”¨ synchronized é”ä½é“¾è¡¨å¤´
- putï¼Œå¦‚æœè¯¥ bin å°šæœªåˆ›å»ºï¼Œåªéœ€è¦ä½¿ç”¨ cas åˆ›å»º binï¼›å¦‚æœå·²ç»æœ‰äº†ï¼Œé”ä½é“¾è¡¨å¤´è¿›è¡Œåç»­ put æ“ä½œï¼Œå…ƒç´ æ·»åŠ è‡³ bin çš„å°¾éƒ¨
- getï¼Œæ— é”æ“ä½œä»…éœ€è¦ä¿è¯å¯è§æ€§ï¼Œæ‰©å®¹è¿‡ç¨‹ä¸­ get æ“ä½œæ‹¿åˆ°çš„æ˜¯ ForwardingNode å®ƒä¼šè®© get æ“ä½œåœ¨æ–°table è¿›è¡Œæœç´¢
- æ‰©å®¹ï¼Œæ‰©å®¹æ—¶ä»¥ bin ä¸ºå•ä½è¿›è¡Œï¼Œéœ€è¦å¯¹ bin è¿›è¡Œ synchronizedï¼Œä½†è¿™æ—¶å¦™çš„æ˜¯å…¶å®ƒç«äº‰çº¿ç¨‹ä¹Ÿä¸æ˜¯æ— äº‹å¯ åšï¼Œå®ƒä»¬ä¼šå¸®åŠ©æŠŠå…¶å®ƒ bin è¿›è¡Œæ‰©å®¹ï¼Œæ‰©å®¹æ—¶å¹³å‡åªæœ‰ 1/6 çš„èŠ‚ç‚¹ä¼šæŠŠå¤åˆ¶åˆ°æ–° table ä¸­
- sizeï¼Œå…ƒç´ ä¸ªæ•°ä¿å­˜åœ¨ baseCount ä¸­ï¼Œå¹¶å‘æ—¶çš„ä¸ªæ•°å˜åŠ¨ä¿å­˜åœ¨ CounterCell[] å½“ä¸­ã€‚æœ€åç»Ÿè®¡æ•°é‡æ—¶ç´¯åŠ  å³å¯





##### 3. JDK7 ConcurrentHashMap

å®ƒç»´æŠ¤äº†ä¸€ä¸ª segment æ•°ç»„ï¼Œæ¯ä¸ª segment å¯¹åº”ä¸€æŠŠé”

- ä¼˜ç‚¹ï¼šå¦‚æœå¤šä¸ªçº¿ç¨‹è®¿é—®ä¸åŒçš„ segmentï¼Œå®é™…æ˜¯æ²¡æœ‰å†²çªçš„ï¼Œè¿™ä¸ jdk8 ä¸­æ˜¯ç±»ä¼¼çš„
- ç¼ºç‚¹ï¼šSegments æ•°ç»„é»˜è®¤å¤§å°ä¸º16ï¼Œè¿™ä¸ªå®¹é‡åˆå§‹åŒ–æŒ‡å®šåå°±ä¸èƒ½æ”¹å˜äº†ï¼Œå¹¶ä¸”ä¸æ˜¯æ‡’æƒ°åˆå§‹åŒ–

**1. æ„é€ å™¨åˆ†æ**

```java
public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {
    if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)
        throw new IllegalArgumentException();
    if (concurrencyLevel > MAX_SEGMENTS)
        concurrencyLevel = MAX_SEGMENTS;
    // ssize å¿…é¡»æ˜¯ 2^n, å³ 2, 4, 8, 16 ... è¡¨ç¤ºäº† segments æ•°ç»„çš„å¤§å°
    int sshift = 0;
    int ssize = 1;
    while (ssize < concurrencyLevel) {
        ++sshift;
        ssize <<= 1;
    }
    // segmentShift é»˜è®¤æ˜¯ 32 - 4 = 28
    this.segmentShift = 32 - sshift;
    // segmentMask é»˜è®¤æ˜¯ 15 å³ 0000 0000 0000 1111
    this.segmentMask = ssize - 1;
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    int c = initialCapacity / ssize;
    if (c * ssize < initialCapacity)
        ++c;
    int cap = MIN_SEGMENT_TABLE_CAPACITY;
    while (cap < c)
        cap <<= 1;
    // åˆ›å»º segments and segments[0]
    Segment<K,V> s0 =
        new Segment<K,V>(loadFactor, (int)(cap * loadFactor),
                         (HashEntry<K,V>[])new HashEntry[cap]);
    Segment<K,V>[] ss = (Segment<K,V>[])new Segment[ssize];
    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
    this.segments = ss;
}
```

æ„é€ å®Œæˆï¼Œå¦‚ä¸‹å›¾æ‰€ç¤º

![](https://gitee.com/eardh/picture/blob/master/Jconcurrent_img/202111192052718.png)

å¯ä»¥çœ‹åˆ° ConcurrentHashMap æ²¡æœ‰å®ç°æ‡’æƒ°åˆå§‹åŒ–ï¼Œç©ºé—´å ç”¨ä¸å‹å¥½

å…¶ä¸­ this.segmentShift å’Œ this.segmentMask çš„ä½œç”¨æ˜¯å†³å®šå°† key çš„ hash ç»“æœåŒ¹é…åˆ°å“ªä¸ª segment

ä¾‹å¦‚ï¼Œæ ¹æ®æŸä¸€ hash å€¼æ±‚ segment ä½ç½®ï¼Œå…ˆå°†é«˜ä½å‘ä½ä½ç§»åŠ¨ this.segmentShift ä½

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192126808.png)

ç»“æœå†ä¸ this.segmentMask åšä½äºè¿ç®—ï¼Œæœ€ç»ˆå¾—åˆ° 1010 å³ä¸‹æ ‡ä¸º 10 çš„ segment

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111192126653.png)



**2. put æµç¨‹**

```java
public V put(K key, V value) {
    Segment<K,V> s;
    if (value == null)
        throw new NullPointerException();
    int hash = hash(key);
    // è®¡ç®—å‡º segment ä¸‹æ ‡
    int j = (hash >>> segmentShift) & segmentMask;

    // è·å¾— segment å¯¹è±¡, åˆ¤æ–­æ˜¯å¦ä¸º null, æ˜¯åˆ™åˆ›å»ºè¯¥ segment
    if ((s = (Segment<K,V>)UNSAFE.getObject 
         (segments, (j << SSHIFT) + SBASE)) == null) {
        // è¿™æ—¶ä¸èƒ½ç¡®å®šæ˜¯å¦çœŸçš„ä¸º null, å› ä¸ºå…¶å®ƒçº¿ç¨‹ä¹Ÿå‘ç°è¯¥ segment ä¸º null,
        // å› æ­¤åœ¨ ensureSegment é‡Œç”¨ cas æ–¹å¼ä¿è¯è¯¥ segment å®‰å…¨æ€§
        s = ensureSegment(j);
    }
    // è¿›å…¥ segment çš„put æµç¨‹
    return s.put(key, hash, value, false);
}
```

segment ç»§æ‰¿äº†å¯é‡å…¥é”ï¼ˆReentrantLockï¼‰ï¼Œå®ƒçš„ put æ–¹æ³•ä¸º

```java
final V put(K key, int hash, V value, boolean onlyIfAbsent) {
    // å°è¯•åŠ é”
    HashEntry<K,V> node = tryLock() ? null :
    // å¦‚æœä¸æˆåŠŸ, è¿›å…¥ scanAndLockForPut æµç¨‹
    // å¦‚æœæ˜¯å¤šæ ¸ cpu æœ€å¤š tryLock 64 æ¬¡, è¿›å…¥ lock æµç¨‹
    // åœ¨å°è¯•æœŸé—´, è¿˜å¯ä»¥é¡ºä¾¿çœ‹è¯¥èŠ‚ç‚¹åœ¨é“¾è¡¨ä¸­æœ‰æ²¡æœ‰, å¦‚æœæ²¡æœ‰é¡ºä¾¿åˆ›å»ºå‡ºæ¥
    scanAndLockForPut(key, hash, value);

    // æ‰§è¡Œåˆ°è¿™é‡Œ segment å·²ç»è¢«æˆåŠŸåŠ é”, å¯ä»¥å®‰å…¨æ‰§è¡Œ
    V oldValue;
    try {
        HashEntry<K,V>[] tab = table;
        int index = (tab.length - 1) & hash;
        HashEntry<K,V> first = entryAt(tab, index);
        for (HashEntry<K,V> e = first;;) {
            if (e != null) {
                // æ›´æ–°
                K k;
                if ((k = e.key) == key ||
                    (e.hash == hash && key.equals(k))) { 
                    oldValue = e.value;
                    if (!onlyIfAbsent) {
                        e.value = value;
                        ++modCount;
                    }
                    break;
                }
                e = e.next;
            }
            else {
                // æ–°å¢
                // 1) ä¹‹å‰ç­‰å¾…é”æ—¶, node å·²ç»è¢«åˆ›å»º, next æŒ‡å‘é“¾è¡¨å¤´
                if (node != null)
                    node.setNext(first);
                else
                    // 2) åˆ›å»ºæ–° node
                    node = new HashEntry<K,V>(hash, key, value, first);
                int c = count + 1; 
                // 3) æ‰©å®¹
                if (c > threshold && tab.length < MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    // å°† node ä½œä¸ºé“¾è¡¨å¤´
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            }
        }
    } finally {
        unlock();
    }
    return oldValue;
}
```



**3. rehash æµç¨‹**

å‘ç”Ÿåœ¨ put ä¸­ï¼Œå› ä¸ºæ­¤æ—¶å·²ç»è·å¾—äº†é”ï¼Œå› æ­¤ rehash æ—¶ä¸éœ€è¦è€ƒè™‘çº¿ç¨‹å®‰å…¨

```java
private void rehash(HashEntry<K,V> node) {
    HashEntry<K,V>[] oldTable = table;
    int oldCapacity = oldTable.length;
    int newCapacity = oldCapacity << 1;
    threshold = (int)(newCapacity * loadFactor);
    HashEntry<K,V>[] newTable =
        (HashEntry<K,V>[]) new HashEntry[newCapacity];
    int sizeMask = newCapacity - 1;
    for (int i = 0; i < oldCapacity ; i++) {
        HashEntry<K,V> e = oldTable[i];
        if (e != null) {
            HashEntry<K,V> next = e.next;
            int idx = e.hash & sizeMask;
            if (next == null) // Single node on list
                newTable[idx] = e;
            else { // Reuse consecutive sequence at same slot
                HashEntry<K,V> lastRun = e;
                int lastIdx = idx;
                // è¿‡ä¸€éé“¾è¡¨, å°½å¯èƒ½æŠŠ rehash å idx ä¸å˜çš„èŠ‚ç‚¹é‡ç”¨
                for (HashEntry<K,V> last = next;
                     last != null;
                     last = last.next) {
                    int k = last.hash & sizeMask;
                    if (k != lastIdx) {
                        lastIdx = k;
                        lastRun = last;
                    }
                }
                newTable[lastIdx] = lastRun;
                // å‰©ä½™èŠ‚ç‚¹éœ€è¦æ–°å»º
                for (HashEntry<K,V> p = e; p != lastRun; p = p.next) {
                    V v = p.value;
                    int h = p.hash;
                    int k = h & sizeMask;
                    HashEntry<K,V> n = newTable[k];
                    newTable[k] = new HashEntry<K,V>(h, p.key, v, n);
                }
            }
        }
    }
    // æ‰©å®¹å®Œæˆ, æ‰åŠ å…¥æ–°çš„èŠ‚ç‚¹
    int nodeIndex = node.hash & sizeMask; // add the new node
    node.setNext(newTable[nodeIndex]);
    newTable[nodeIndex] = node;

    // æ›¿æ¢ä¸ºæ–°çš„ HashEntry table
    table = newTable;
}
```

é™„ï¼Œè°ƒè¯•ä»£ç 

```java
public static void main(String[] args) {
    ConcurrentHashMap<Integer, String> map = new ConcurrentHashMap<>();
    for (int i = 0; i < 1000; i++) {
        int hash = hash(i);
        int segmentIndex = (hash >>> 28) & 15;
        if (segmentIndex == 4 && hash % 8 == 2) {
            System.out.println(i + "\t" + segmentIndex + "\t" + hash % 2 + "\t" + hash % 4 +
                               "\t" + hash % 8);
        }
    }
    map.put(1, "value");
    map.put(15, "value"); // 2 æ‰©å®¹ä¸º 4 15 çš„ hash%8 ä¸å…¶ä»–ä¸åŒ
    map.put(169, "value");
    map.put(197, "value"); // 4 æ‰©å®¹ä¸º 8
    map.put(341, "value");
    map.put(484, "value");
    map.put(545, "value"); // 8 æ‰©å®¹ä¸º 16
    map.put(912, "value");
    map.put(941, "value");
    System.out.println("ok");
}

private static int hash(Object k) {
    int h = 0;
    if ((0 != h) && (k instanceof String)) {
        return sun.misc.Hashing.stringHash32((String) k);
    }
    h ^= k.hashCode();
    // Spread bits to regularize both segment and index locations,
    // using variant of single-word Wang/Jenkins hash.
    h += (h << 15) ^ 0xffffcd7d;
    h ^= (h >>> 10);
    h += (h << 3);
    h ^= (h >>> 6);
    h += (h << 2) + (h << 14);
    int v = h ^ (h >>> 16);
    return v;
}
```



**4. get æµç¨‹**

get æ—¶å¹¶æœªåŠ é”ï¼Œç”¨äº† UNSAFE æ–¹æ³•ä¿è¯äº†å¯è§æ€§ï¼Œæ‰©å®¹è¿‡ç¨‹ä¸­ï¼Œget å…ˆå‘ç”Ÿå°±ä»æ—§è¡¨å–å†…å®¹ï¼Œget åå‘ç”Ÿå°±ä»æ–° è¡¨å–å†…å®¹

```java
public V get(Object key) {
    Segment<K,V> s; // manually integrate access methods to reduce overhead
    HashEntry<K,V>[] tab;
    int h = hash(key);
    // u ä¸º segment å¯¹è±¡åœ¨æ•°ç»„ä¸­çš„åç§»é‡
    long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;
    // s å³ä¸º segment
    if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&
        (tab = s.table) != null) {
        for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile
             (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);
             e != null; e = e.next) {
            K k;
            if ((k = e.key) == key || (e.hash == h && key.equals(k)))
                return e.value;
        }
    }
    return null;
}
```



**5. size è®¡ç®—æµç¨‹**

- è®¡ç®—å…ƒç´ ä¸ªæ•°å‰ï¼Œå…ˆä¸åŠ é”è®¡ç®—ä¸¤æ¬¡ï¼Œå¦‚æœå‰åä¸¤æ¬¡ç»“æœå¦‚ä¸€æ ·ï¼Œè®¤ä¸ºä¸ªæ•°æ­£ç¡®è¿”å›
- å¦‚æœä¸ä¸€æ ·ï¼Œè¿›è¡Œé‡è¯•ï¼Œé‡è¯•æ¬¡æ•°è¶…è¿‡ 3ï¼Œå°†æ‰€æœ‰ segment é”ä½ï¼Œé‡æ–°è®¡ç®—ä¸ªæ•°è¿”å›

```java
public int size() {
    // Try a few times to get accurate count. On failure due to
    // continuous async changes in table, resort to locking.
    final Segment<K,V>[] segments = this.segments;
    int size;
    boolean overflow; // true if size overflows 32 bits
    long sum; // sum of modCounts
    long last = 0L; // previous sum
    int retries = -1; // first iteration isn't retry
    try {
        for (;;) {
            if (retries++ == RETRIES_BEFORE_LOCK) {
                // è¶…è¿‡é‡è¯•æ¬¡æ•°, éœ€è¦åˆ›å»ºæ‰€æœ‰ segment å¹¶åŠ é”
                for (int j = 0; j < segments.length; ++j)
                    ensureSegment(j).lock(); // force creation
            }
            sum = 0L;
            size = 0;
            overflow = false;
            for (int j = 0; j < segments.length; ++j) {
                Segment<K,V> seg = segmentAt(segments, j);
                if (seg != null) {
                    sum += seg.modCount;
                    int c = seg.count;
                    if (c < 0 || (size += c) < 0)
                        overflow = true;
                }
            }
            if (sum == last)
                break;
            last = sum;
        }
    } finally {
        if (retries > RETRIES_BEFORE_LOCK) {
            for (int j = 0; j < segments.length; ++j)
                segmentAt(segments, j).unlock();
        }
    }
    return overflow ? Integer.MAX_VALUE : size;
}
```







### 9. BlockingQueue

**LinkedBlockingQueue åŸç†**

#### 1. åŸºæœ¬çš„å…¥é˜Ÿå‡ºé˜Ÿ

```java
public class LinkedBlockingQueue<E> extends AbstractQueue<E>
    implements BlockingQueue<E>, java.io.Serializable {
    static class Node<E> {
        E item;
       /**
 		* ä¸‹åˆ—ä¸‰ç§æƒ…å†µä¹‹ä¸€
		* - çœŸæ­£çš„åç»§èŠ‚ç‚¹
		* - è‡ªå·±, å‘ç”Ÿåœ¨å‡ºé˜Ÿæ—¶
		* - null, è¡¨ç¤ºæ˜¯æ²¡æœ‰åç»§èŠ‚ç‚¹, æ˜¯æœ€åäº†
 		*/
        Node<E> next;
        Node(E x) { item = x; }
    }
}
```

åˆå§‹åŒ–é“¾è¡¨ `last = head = new Node(null);` Dummy èŠ‚ç‚¹ç”¨æ¥å ä½ï¼Œitem ä¸º null

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111201207839.png)

å½“ä¸€ä¸ªèŠ‚ç‚¹å…¥é˜Ÿ `last = last.next = node;`

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111201208470.png)

å†æ¥ä¸€ä¸ªèŠ‚ç‚¹å…¥é˜Ÿ `last = last.next = node;`

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111201209308.png)

å‡ºé˜Ÿ

```java
Node<E> h = head;
Node<E> first = h.next;
h.next = h; // help GC
head = first;
E x = first.item;
first.item = null;
return x;
```

`h = head`

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111201209302.png)

`first = h.next`

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111201209560.png)

`h.next = h`

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111201209223.png)

`head = first`

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111201210226.png)

```java
E x = first.item;
first.item = null;
return x;
```

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111201210476.png)





#### 2. åŠ é”åˆ†æ

==é«˜æ˜ä¹‹å¤„==åœ¨äºç”¨äº†ä¸¤æŠŠé”å’Œ dummy èŠ‚ç‚¹

- ç”¨ä¸€æŠŠé”ï¼ŒåŒä¸€æ—¶åˆ»ï¼Œæœ€å¤šåªå…è®¸æœ‰ä¸€ä¸ªçº¿ç¨‹ï¼ˆç”Ÿäº§è€…æˆ–æ¶ˆè´¹è€…ï¼ŒäºŒé€‰ä¸€ï¼‰æ‰§è¡Œ

- ç”¨ä¸¤æŠŠé”ï¼ŒåŒä¸€æ—¶åˆ»ï¼Œå¯ä»¥å…è®¸ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶ï¼ˆä¸€ä¸ªç”Ÿäº§è€…ä¸ä¸€ä¸ªæ¶ˆè´¹è€…ï¼‰æ‰§è¡Œ
  - æ¶ˆè´¹è€…ä¸æ¶ˆè´¹è€…çº¿ç¨‹ä»ç„¶ä¸²è¡Œ
  - ç”Ÿäº§è€…ä¸ç”Ÿäº§è€…çº¿ç¨‹ä»ç„¶ä¸²è¡Œ

çº¿ç¨‹å®‰å…¨åˆ†æ

- å½“èŠ‚ç‚¹æ€»æ•°å¤§äº 2 æ—¶ï¼ˆåŒ…æ‹¬ dummy èŠ‚ç‚¹ï¼‰ï¼ŒputLock ä¿è¯çš„æ˜¯ last èŠ‚ç‚¹çš„çº¿ç¨‹å®‰å…¨ï¼ŒtakeLock ä¿è¯çš„æ˜¯ head èŠ‚ç‚¹çš„çº¿ç¨‹å®‰å…¨ã€‚ä¸¤æŠŠé”ä¿è¯äº†å…¥é˜Ÿå’Œå‡ºé˜Ÿæ²¡æœ‰ç«äº‰
- å½“èŠ‚ç‚¹æ€»æ•°ç­‰äº 2 æ—¶ï¼ˆå³ä¸€ä¸ª dummy èŠ‚ç‚¹ï¼Œä¸€ä¸ªæ­£å¸¸èŠ‚ç‚¹ï¼‰è¿™æ—¶å€™ï¼Œä»ç„¶æ˜¯ä¸¤æŠŠé”é”ä¸¤ä¸ªå¯¹è±¡ï¼Œä¸ä¼šç«äº‰
- å½“èŠ‚ç‚¹æ€»æ•°ç­‰äº 1 æ—¶ï¼ˆå°±ä¸€ä¸ª dummy èŠ‚ç‚¹ï¼‰è¿™æ—¶ take çº¿ç¨‹ä¼šè¢« notEmpty æ¡ä»¶é˜»å¡ï¼Œæœ‰ç«äº‰ï¼Œä¼šé˜»å¡

```java
// ç”¨äº put(é˜»å¡) offer(éé˜»å¡)
private final ReentrantLock putLock = new ReentrantLock();

// ç”¨æˆ· take(é˜»å¡) poll(éé˜»å¡)
private final ReentrantLock takeLock = new ReentrantLock();
```

put æ“ä½œ

````java
public void put(E e) throws InterruptedException {
    if (e == null) throw new NullPointerException();
    int c = -1;
    Node<E> node = new Node<E>(e);
    final ReentrantLock putLock = this.putLock;
    // count ç”¨æ¥ç»´æŠ¤å…ƒç´ è®¡æ•°
    final AtomicInteger count = this.count;
    putLock.lockInterruptibly();
    try {
        // æ»¡äº†ç­‰å¾…
        while (count.get() == capacity) {
            // å€’è¿‡æ¥è¯»å°±å¥½: ç­‰å¾… notFull
            notFull.await();
        }
        // æœ‰ç©ºä½, å…¥é˜Ÿä¸”è®¡æ•°åŠ ä¸€
        enqueue(node);
        c = count.getAndIncrement(); 
        // é™¤äº†è‡ªå·± put ä»¥å¤–, é˜Ÿåˆ—è¿˜æœ‰ç©ºä½, ç”±è‡ªå·±å«é†’å…¶ä»– put çº¿ç¨‹
        if (c + 1 < capacity)
            notFull.signal();
    } finally {
        putLock.unlock();
    }
    // å¦‚æœé˜Ÿåˆ—ä¸­æœ‰ä¸€ä¸ªå…ƒç´ , å«é†’ take çº¿ç¨‹
    if (c == 0)
        // è¿™é‡Œè°ƒç”¨çš„æ˜¯ notEmpty.signal() è€Œä¸æ˜¯ notEmpty.signalAll() æ˜¯ä¸ºäº†å‡å°‘ç«äº‰
        signalNotEmpty();
}
````

take æ“ä½œ

```java
public E take() throws InterruptedException {
    E x;
    int c = -1;
    final AtomicInteger count = this.count;
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lockInterruptibly();
    try {
        while (count.get() == 0) {
            notEmpty.await();
        }
        x = dequeue();
        c = count.getAndDecrement();
        if (c > 1)
            notEmpty.signal();
    } finally {
        takeLock.unlock();
    }
    // å¦‚æœé˜Ÿåˆ—ä¸­åªæœ‰ä¸€ä¸ªç©ºä½æ—¶, å«é†’ put çº¿ç¨‹
    // å¦‚æœæœ‰å¤šä¸ªçº¿ç¨‹è¿›è¡Œå‡ºé˜Ÿ, ç¬¬ä¸€ä¸ªçº¿ç¨‹æ»¡è¶³ c == capacity, ä½†åç»­çº¿ç¨‹ c < capacity
    if (c == capacity)
        // è¿™é‡Œè°ƒç”¨çš„æ˜¯ notFull.signal() è€Œä¸æ˜¯ notFull.signalAll() æ˜¯ä¸ºäº†å‡å°‘ç«äº‰
        signalNotFull()
        return x;
}
```

> ç”± put å”¤é†’ put æ˜¯ä¸ºäº†é¿å…ä¿¡å·ä¸è¶³





#### 3. æ€§èƒ½æ¯”è¾ƒ

ä¸»è¦åˆ—ä¸¾ LinkedBlockingQueue ä¸ ArrayBlockingQueue çš„æ€§èƒ½æ¯”è¾ƒ

- Linked æ”¯æŒæœ‰ç•Œï¼ŒArray å¼ºåˆ¶æœ‰ç•Œ
- Linked å®ç°æ˜¯é“¾è¡¨ï¼ŒArray å®ç°æ˜¯æ•°ç»„
- Linked æ˜¯æ‡’æƒ°çš„ï¼Œè€Œ Array éœ€è¦æå‰åˆå§‹åŒ– Node æ•°ç»„
- Linked æ¯æ¬¡å…¥é˜Ÿä¼šç”Ÿæˆæ–° Nodeï¼Œè€Œ Array çš„ Node æ˜¯æå‰åˆ›å»ºå¥½çš„
- Linked ä¸¤æŠŠé”ï¼ŒArray ä¸€æŠŠé”







### 10. ConcurrentLinkedQueue

ConcurrentLinkedQueue çš„è®¾è®¡ä¸ LinkedBlockingQueue éå¸¸åƒï¼Œä¹Ÿæ˜¯

- ä¸¤æŠŠã€é”ã€‘ï¼ŒåŒä¸€æ—¶åˆ»ï¼Œå¯ä»¥å…è®¸ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶ï¼ˆä¸€ä¸ªç”Ÿäº§è€…ä¸ä¸€ä¸ªæ¶ˆè´¹è€…ï¼‰æ‰§è¡Œ
- dummy èŠ‚ç‚¹çš„å¼•å…¥è®©ä¸¤æŠŠã€é”ã€‘å°†æ¥é”ä½çš„æ˜¯ä¸åŒå¯¹è±¡ï¼Œé¿å…ç«äº‰
- åªæ˜¯è¿™ã€é”ã€‘ä½¿ç”¨äº† cas æ¥å®ç°

äº‹å®ä¸Šï¼ŒConcurrentLinkedQueue åº”ç”¨è¿˜æ˜¯éå¸¸å¹¿æ³›çš„

ä¾‹å¦‚ä¹‹å‰è®²çš„ Tomcat çš„ Connector ç»“æ„æ—¶ï¼ŒAcceptor ä½œä¸ºç”Ÿäº§è€…å‘ Poller æ¶ˆè´¹è€…ä¼ é€’äº‹ä»¶ä¿¡æ¯æ—¶ï¼Œæ­£æ˜¯é‡‡ç”¨äº† ConcurrentLinkedQueue å°† SocketChannel ç»™ Poller ä½¿ç”¨

#### ![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111201412346.png)







### 11. CopyOnWriteArrayList

`CopyOnWriteArraySet` æ˜¯å®ƒçš„é©¬ç”²

åº•å±‚å®ç°é‡‡ç”¨äº† å†™å…¥æ—¶æ‹·è´ çš„æ€æƒ³ï¼Œå¢åˆ æ”¹æ“ä½œä¼šå°†åº•å±‚æ•°ç»„æ‹·è´ä¸€ä»½ï¼Œæ›´ æ”¹æ“ä½œåœ¨æ–°æ•°ç»„ä¸Šæ‰§è¡Œï¼Œè¿™æ—¶ä¸å½±å“å…¶å®ƒçº¿ç¨‹çš„**å¹¶å‘è¯»**ï¼Œ**è¯»å†™åˆ†ç¦»**ã€‚

ä»¥æ–°å¢ä¸ºä¾‹ï¼š

```java
public boolean add(E e) {
    synchronized (lock) {
        // è·å–æ—§çš„æ•°ç»„
        Object[] es = getArray();
        int len = es.length;
        // æ‹·è´æ–°çš„æ•°ç»„ï¼ˆè¿™é‡Œæ˜¯æ¯”è¾ƒè€—æ—¶çš„æ“ä½œï¼Œä½†ä¸å½±å“å…¶å®ƒè¯»çº¿ç¨‹ï¼‰
        es = Arrays.copyOf(es, len + 1);
        // æ·»åŠ æ–°å…ƒç´ 
        es[len] = e;
        // æ›¿æ¢æ—§çš„æ•°ç»„
        setArray(es);
        return true;
    }
}
```

> è¿™é‡Œçš„æºç ç‰ˆæœ¬æ˜¯ Java 11ï¼Œåœ¨ Java 1.8 ä¸­ä½¿ç”¨çš„æ˜¯å¯é‡å…¥é”è€Œä¸æ˜¯ synchronized

å…¶å®ƒè¯»æ“ä½œå¹¶æœªåŠ é”ï¼Œä¾‹å¦‚ï¼š

```java
public void forEach(Consumer<? super E> action) {
    Objects.requireNonNull(action);
    for (Object x : getArray()) {
        @SuppressWarnings("unchecked") E e = (E) x;
        action.accept(e);
    }
}
```

é€‚åˆã€è¯»å¤šå†™å°‘ã€çš„åº”ç”¨åœºæ™¯



#### 1. get å¼±ä¸€è‡´æ€§

![](https://gitlab.com/eardh/picture/-/raw/main/Jconcurrent_img/202111201211933.png)

| æ—¶é—´ç‚¹ | æ“ä½œ                         |
| ------ | ---------------------------- |
| 1      | Thread-0 getArray()          |
| 2      | Thread-1 getArray()          |
| 3      | Thread-1 setArray(arrayCopy) |
| 4      | Thread-1 setArray(arrayCopy) |

> ä¸å®¹æ˜“æµ‹è¯•ï¼Œä½†é—®é¢˜ç¡®å®å­˜åœ¨





#### 2. è¿­ä»£å™¨å¼±ä¸€è‡´æ€§

```java
CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();
list.add(1);
list.add(2);
list.add(3);
Iterator<Integer> iter = list.iterator();
new Thread(() -> {
    list.remove(0);
    System.out.println(list);
}).start();
sleep1s();
while (iter.hasNext()) {
    System.out.println(iter.next());
}
```

> ä¸è¦è§‰å¾—å¼±ä¸€è‡´æ€§å°±ä¸å¥½
>
> - æ•°æ®åº“çš„ MVCC éƒ½æ˜¯å¼±ä¸€è‡´æ€§çš„è¡¨ç°
> - å¹¶å‘é«˜å’Œä¸€è‡´æ€§æ˜¯çŸ›ç›¾çš„ï¼Œéœ€è¦æƒè¡¡







